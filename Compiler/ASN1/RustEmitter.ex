defmodule ASN1.RustEmitter do
  IO.puts("Defining ASN1.RustEmitter module...")
  @behaviour ASN1.Emitter

  import ASN1,
    only: [bin: 1, normalizeName: 1, getEnv: 2, setEnv: 2, save: 4, lookup: 1, outputDir: 0]

  @reserved_field_names ~w(type self super Self crate use mod pub fn struct enum impl let mut ref loop match abstract async await become box const continue do dyn else extern false final for if in macro move override priv public pure return static trait true try typeof unsafe unsized virtual where while yield)
  @default_derives "#[derive(Clone, Debug)]"
  @generated_header "// Generated by ASN1.ERP.UNO Compiler -- Rust emitter" <> "\n"
  @reserved_variant_names ~w(Self)

  @builtin_type_map %{
    :"OBJECT IDENTIFIER" => "ASN1ObjectIdentifier",
    "OBJECT IDENTIFIER" => "ASN1ObjectIdentifier",
    :"BIT STRING" => "ASN1BitString",
    "BIT STRING" => "ASN1BitString",
    :"OCTET STRING" => "ASN1OctetString",
    "OCTET STRING" => "ASN1OctetString",
    :BOOLEAN => "ASN1Boolean",
    "BOOLEAN" => "ASN1Boolean",
    :INTEGER => "ASN1Integer",
    "INTEGER" => "ASN1Integer",
    :REAL => "ASN1Real",
    "REAL" => "ASN1Real",
    :ENUMERATED => "ASN1Integer",
    "ENUMERATED" => "ASN1Integer",
    :NULL => "ASN1Null",
    "NULL" => "ASN1Null",
    :UTF8String => "ASN1UTF8String",
    "UTF8String" => "ASN1UTF8String",
    :Printablestring => "ASN1PrintableString",
    "Printablestring" => "ASN1PrintableString",
    :PrintableString => "ASN1PrintableString",
    "PrintableString" => "ASN1PrintableString",
    :IA5String => "ASN1IA5String",
    "IA5String" => "ASN1IA5String",
    :NumericString => "ASN1NumericString",
    "NumericString" => "ASN1NumericString",
    :GeneralizedTime => "GeneralizedTime",
    "GeneralizedTime" => "GeneralizedTime",
    :UTCTime => "UTCTime",
    "UTCTime" => "UTCTime",
    :ANY => "ASN1Node",
    "ANY" => "ASN1Node",
    :ASN1Any => "ASN1Node",
    "ASN1Any" => "ASN1Node",
    # Mapped to OctetString or similar usually? rust_asn1 might not have it.
    :TeletexString => "ASN1UTF8String",
    "TeletexString" => "ASN1UTF8String",
    :BMPString => "ASN1UTF8String",
    "BMPString" => "ASN1UTF8String",
    :UniversalString => "ASN1UTF8String",
    "UniversalString" => "ASN1UTF8String",
    :GeneralString => "ASN1UTF8String",
    "GeneralString" => "ASN1UTF8String",
    :GraphicString => "ASN1UTF8String",
    "GraphicString" => "ASN1UTF8String",
    :VideotexString => "ASN1UTF8String",
    "VideotexString" => "ASN1UTF8String",
    :ObjectDescriptor => "ASN1UTF8String",
    "ObjectDescriptor" => "ASN1UTF8String",
    :VisibleString => "ASN1UTF8String",
    "VisibleString" => "ASN1UTF8String",
    # Generic handling
    :TYPE_IDENTIFIER => "ASN1Node",
    "TYPE-IDENTIFIER" => "ASN1Node",
    :Sequence => "ASN1Node",
    "Sequence" => "ASN1Node",
    :Choice => "ASN1Node",
    "Choice" => "ASN1Node",
    :Set => "ASN1Node",
    "Set" => "ASN1Node",
    :SET => "ASN1Node",
    "SET" => "ASN1Node",
    :ATTRIBUTE => "ASN1ObjectIdentifier",
    "ATTRIBUTE" => "ASN1ObjectIdentifier",
    "AttributeType" => "ASN1ObjectIdentifier",
    :AttributeType => "ASN1ObjectIdentifier",
    # Map AlgorithmIdentifier to the canonical version in algorithminformation2009
    "AlgorithmIdentifier" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    :AlgorithmIdentifier =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "PKIX1Explicit2009AlgorithmIdentifier" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "PKIX1Explicit2009Algorithm" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "AlgorithmInformation2009Algorithm" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    # SubjectPublicKeyInfo mappings
    "SubjectPublicKeyInfo" =>
      "pkix1explicit88::pkix1_explicit88::PKIX1Explicit88SubjectPublicKeyInfo",
    "PKCS10SubjectPublicKeyInfo" =>
      "pkix1explicit88::pkix1_explicit88::PKIX1Explicit88SubjectPublicKeyInfo",
    "InformationFrameworkATTRIBUTE" => "ASN1ObjectIdentifier",
    "ANSIX942AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "ANSIX942AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "ANSIX962AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "ANSIX962AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "AttributeCertificateVersion12009AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "CryptographicMessageSyntax2009Attribute" =>
      "crate::pkix_common_types2009::pkixcommontypes2009attribute::PKIXCommonTypes2009Attribute",
    "CharacterPresentationAttributesCharacterAttributes" => "ASN1Node",
    "PKIXAttributeCertificate2009AttributeCertificate" =>
      "crate::attribute_certificate_version12009::attributecertificateversion12009attributecertificatev1::AttributeCertificateVersion12009AttributeCertificateV1",
    "CryptographicMessageSyntax2010AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "TextUnitsTextUnit" => "crate::text_units::textunitstextunit::TextUnitsTextUnit",
    "StyleDescriptorsLayoutStyleDescriptor" =>
      "crate::style_descriptors::styledescriptorslayoutstyledescriptor::StyleDescriptorsLayoutStyleDescriptor",
    "StyleDescriptorsPresentationStyleDescriptor" =>
      "crate::style_descriptors::styledescriptorspresentationstyledescriptor::StyleDescriptorsPresentationStyleDescriptor",
    "SubprofilesSubprofileDescriptor" =>
      "crate::subprofiles::subprofilessubprofiledescriptor::SubprofilesSubprofileDescriptor",
    "PKCS10AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "CryptographicMessageSyntax2010ContentInfo" =>
      "crate::cryptographic_message_syntax2010::cryptographicmessagesyntax2010contentinfo::CryptographicMessageSyntax2010ContentInfo",
    "PKIXCRMF2009PrivateKeyInfo" =>
      "crate::pkixcrmf2009::pkixcrmf2009privatekeyinfo::PKIXCRMF2009PrivateKeyInfo",
    "PKCS8EncryptedPrivateKeyInfo" =>
      "crate::pkcs8::pkcs8encryptedprivatekeyinfo::PKCS8EncryptedPrivateKeyInfo",
    "PKCS7AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "PKCS7AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::algorithm_information2009::algorithminformation2009algorithm::AlgorithmInformation2009Algorithm",
    "PKCS9DirectoryString" =>
      "crate::selected_attribute_types::selectedattributetypesdirectorystring::SelectedAttributeTypesDirectoryString",
    "PKIX1Explicit2009AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "PKIX1Explicit88AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "PKCS5AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "CryptographicMessageSyntax2010Attribute" =>
      "crate::pkix_common_types2009::pkixcommontypes2009attribute::PKIXCommonTypes2009Attribute",
    "PKIXAttributeCertificate2009AlgorithmIdentifier" =>
      "crate::authentication_framework::AuthenticationFrameworkAlgorithmIdentifier",
    "AttributeType" => "ASN1ObjectIdentifier",
    "ContentType" => "ASN1ObjectIdentifier",
    "PKCS7ContentType" => "ASN1ObjectIdentifier",
    "PKCS9ContentType" => "ASN1ObjectIdentifier",
    "CryptographicMessageSyntax2009ContentType" => "ASN1ObjectIdentifier",
    "ExtendedSecurityServices2009ContentType" => "ASN1ObjectIdentifier",
    "StyleDescriptorsContentType" => "crate::StyleDescriptorsContentType",
    "AP-title" => "ASN1Node",
    "AE-qualifier" => "ASN1Node",
    "DORDefinitionAPTitle" => "ASN1Node",
    "DORDefinitionAEQualifier" => "ASN1Node",
    "CharacterProfileAttributesCharacterContentDefaults" => "ASN1Node",
    "RasterGrProfileAttributesRasterGrContentDefaults" => "ASN1Node",
    "GeoGrProfileAttributesGeoGrContentDefaults" => "ASN1Node",
    "DocumentProfileDescriptorDateAndTime" =>
      "crate::document_profile_descriptor::documentprofiledescriptordateandtime::DocumentProfileDescriptorDateAndTime",
    "CryptographicMessageSyntax2010IssuerAndSerialNumber" =>
      "crate::cryptographic_message_syntax2010::cryptographicmessagesyntax2010issuerandserialnumber::CryptographicMessageSyntax2010IssuerAndSerialNumber",
    "LinkDescriptorsLinkClassDescriptor" =>
      "crate::link_descriptors::linkdescriptorslinkclassdescriptor::LinkDescriptorsLinkClassDescriptor",
    "LinkDescriptorsLinkDescriptor" =>
      "crate::link_descriptors::linkdescriptorslinkdescriptor::LinkDescriptorsLinkDescriptor",
    # ORAddress mappings
    "ORAddress" => "ASN1Node",
    "PKIX1Explicit2009ORAddress" => "ASN1Node",
    # Final cleanup mappings
    "EXTERNAL" => "ASN1Node",
    :EXTERNAL => "ASN1Node",
    "AttributeCertificateVersion12009AttributeCertificateV1" => "ASN1Node",
    "KEPTime" => "x500::authentication_framework::AuthenticationFrameworkTime",
    "CryptographicMessageSyntax2009AlgorithmInformation2009AlgorithmIdentifier" =>
      "algorithminformation2009::algorithm_information2009::AlgorithmInformation2009Algorithm"
  }

  # Region: behaviour callbacks ----------------------------------------------------

  @modules [
    "PKIX1Explicit88",
    "PKIX1Implicit2009",
    "PKIX1Explicit2009",
    "PKIXCommonTypes2009",
    "AuthenticationFramework",
    "CertificateExtensions",
    "DirectoryAbstractService",
    "UsefulDefinitions",
    "DSTU",
    "LDAP",
    "AlgorithmInformation2009",
    "InformationFramework",
    "SelectedAttributeTypes"
  ]

  @impl true
  def fileExtension, do: ".rs"

  @impl true
  def builtinType(type) when is_atom(type) do
    Map.get(@builtin_type_map, type, "ASN1Node")
  end

  defp builtin_map_lookup(type) do
    Map.get(@builtin_type_map, type)
  end

  defp vector_element(vec_type) when is_binary(vec_type) do
    vec_type
    |> strip_generic("Box<")
    |> strip_generic("Vec<")
    |> String.trim()
  end

  defp strip_generic(type, prefix) do
    if String.starts_with?(type, prefix) and String.ends_with?(type, ">") do
      prefix_len = String.length(prefix)
      String.slice(type, prefix_len..-2//1)
    else
      type
    end
  end

  defp field_type_for(struct_name, field, type, optional) do
    type_name = fieldType(struct_name, field, type)

    base_type =
      type_name
      |> substituteType()
      |> maybe_box(struct_name, field)

    # Ensure internal types have crate:: prefix in single-crate mode
    final_base =
      if is_single_crate?() and not String.contains?(base_type, "::") and
           not is_primitive_or_std_type?(base_type) do
        "crate::" <> base_type
      else
        base_type
      end

    if optional == :OPTIONAL do
      "Option<" <> final_base <> ">"
    else
      final_base
    end
  end

  defp is_primitive_or_std_type?(type) do
    # Trim and handle Option wrappers
    clean = type |> String.replace("Option<", "") |> String.replace(">", "") |> String.trim()

    res =
      Enum.member?(
        [
          "ASN1Integer",
          "ASN1BitString",
          "ASN1OctetString",
          "ASN1ObjectIdentifier",
          "ASN1Boolean",
          "ASN1Null",
          "ASN1Enumerated",
          "ASN1UTF8String",
          "ASN1IA5String",
          "ASN1PrintableString",
          "ASN1NumericString",
          "ASN1TeletexString",
          "ASN1UniversalString",
          "ASN1UTCTime",
          "ASN1GeneralizedTime",
          "ASN1Node",
          "ASN1Any",
          "f64",
          "i32",
          "i64",
          "u32",
          "bool",
          "GeneralizedTime",
          "UTCTime",
          "ObjectDescriptor",
          "ASN1Real",
          "ASN1BMPString",
          "ASN1GeneralString",
          "ASN1VisibleString",
          "ASN1GraphicString",
          "ASN1T61String",
          "ASN1ObjectDescriptor"
        ],
        clean
      ) or String.starts_with?(clean, "Vec<") or String.starts_with?(clean, "Box<") or
        clean == "ASN1Node"

    res
  end

  @impl true
  def name(raw_name, modname) do
    pascal_mod = raw_pascal(modname)
    pascal_type = raw_pascal(raw_name)

    # Consolidate SMIMECAPS fix here
    pascal_type =
      if String.ends_with?(pascal_type, "SMIMECAPS") and
           not String.ends_with?(pascal_type, "SMIMECapabilities") do
        String.replace(pascal_type, "SMIMECAPS", "SMIMECapability")
      else
        pascal_type
      end

    # Fix for AlgorithmIdentifier being renamed to Algorithm in AlgorithmInformation2009
    pascal_type =
      if String.downcase(pascal_mod) == "algorithminformation2009" and
           pascal_type == "AlgorithmIdentifier" do
        "Algorithm"
      else
        # Fix for PKCS5 AlgorithmIdentifier casing
        if String.upcase(pascal_mod) == "PKCS5" and
             String.upcase(pascal_type) == "ALGORITHMIDENTIFIER" do
          "AlgorithmIdentifier"
        else
          pascal_type
        end
      end

    res =
      cond do
        String.starts_with?(pascal_type, pascal_mod) -> pascal_type
        true -> pascal_mod <> pascal_type
      end

    # Ensure no :: in type names if they are being used for definitions
    res |> String.replace("::", "_") |> String.replace("/", "_")
  end

  defp canonical_module_name(modname) do
    modname
    |> bin()
    |> normalizeName()
    |> String.replace("-", "")
    |> String.replace("_", "")
    |> String.replace(".", "")
  end

  @impl true
  def fieldName(name) do
    name
    |> normalizeName()
    |> snake_case()
    |> escape_reserved()
  end

  @impl true
  def fieldType(struct_name, field, {:type, _, inner, _, _, _}) do
    fieldType(struct_name, field, inner)
  end

  def fieldType(struct_name, field, {:pt, {:Externaltypereference, _, _, _} = ref, _args}) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, {:ObjectClassFieldType, _, _, fields, _})
      when is_list(fields) do
    case Keyword.get(fields, :valuefieldreference) do
      :id -> "ASN1ObjectIdentifier"
      _ -> "ASN1Node"
    end
  end

  def fieldType(_struct_name, _field, {:ObjectClassFieldType, _, _, fields, _}) do
    IO.puts("DEBUG ObjectClassFieldType fields=#{inspect(fields)}")

    cond do
      fields == :id -> "ASN1ObjectIdentifier"
      match?({:valuefieldreference, :id}, fields) -> "ASN1ObjectIdentifier"
      true -> "ASN1Node"
    end
  end

  @impl true
  def module_crate(modname) do
    if System.get_env("ASN1_SINGLE_CRATE") do
      "asn1_suite"
    else
      module_crate_internal(modname)
    end
  end

  def module_crate_internal(modname) do
    canon = canonical_module_name(modname)

    if String.contains?(canon, "Algorithm") or String.contains?(canon, "PKIX") do
      "x500"
    else
      case canon do
        "InformationFramework" ->
          "x500"

        "SelectedAttributeTypes" ->
          "x500"

        "DirectoryAbstractService" ->
          "x500"

        "UsefulDefinitions" ->
          "x500"

        "CertificateExtensions" ->
          "x500"

        "AuthenticationFramework" ->
          "x500"

        "DSTU" ->
          "dstu"

        "AlgorithmInformation2009" ->
          "algorithminformation2009"

        "PKIX1Explicit88" ->
          "pkix1explicit88"

        "PKIX1Explicit2009" ->
          "pkix1explicit2009"

        "PKIX1Implicit2009" ->
          "pkix1implicit2009"

        "PKIXCommonTypes2009" ->
          "pkixcommontypes2009"

        "LDAP" ->
          "ldap"

        other ->
          if other == "" do
            ""
          else
            other
            |> String.downcase()
          end
      end
    end
  end

  @doc """
  Track a cross-crate dependency. Called during code generation when
  a type from an external crate is referenced.
  """
  def track_crate_dependency(external_crate) do
    current_module = getEnv(:current_module, "")
    current_crate = module_crate(current_module)

    if external_crate != nil and external_crate != current_crate and external_crate != "" do
      key = {:crate_deps, current_crate}
      existing = :application.get_env(:asn1scg, key, MapSet.new())
      updated = MapSet.put(existing, external_crate)
      :application.set_env(:asn1scg, key, updated)
    end
  end

  @doc """
  Get tracked cross-crate dependencies for a given crate.
  Returns a list of crate names that the given crate depends on.
  """
  def get_crate_dependencies(crate) do
    :application.get_env(:asn1scg, {:crate_deps, crate}, MapSet.new())
    |> MapSet.to_list()
  end

  def fieldType(_struct_name, _field, {:"SEQUENCE OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(_struct_name, _field, {:"SET OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(struct_name, field, {:"Sequence Of", inner}) do
    fieldType(struct_name, field, {:"SEQUENCE OF", inner})
  end

  def fieldType(struct_name, field, {:"Set Of", inner}) do
    fieldType(struct_name, field, {:"SET OF", inner})
  end

  def fieldType(struct_name, field, {:Externaltypereference, _, _, _} = ref) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, atom) when is_atom(atom) do
    atom
    |> Atom.to_string()
    |> lookup_builtin_or_external()
  end

  def fieldType(struct_name, field, other) when is_tuple(other) do
    case other do
      {:CHOICE, _} ->
        name("#{field}_choice", struct_name)

      {:SEQUENCE, _, _, _, _} ->
        name("#{field}_sequence", struct_name)

      {:SET, _, _, _, _} ->
        name("#{field}_set", struct_name)

      {:ENUMERATED, _} ->
        name("#{field}_enum", struct_name)

      {:ANY_DEFINED_BY, _} ->
        "ASN1Node"

      {:INTEGER, _} ->
        "ASN1Integer"

      {:"BIT STRING", _} ->
        "ASN1BitString"

      {:"INSTANCE OF", _, _} ->
        "ASN1Node"

      {:SelectionType, _field_name, {:type, _, type_ref, _, _, _}} ->
        fieldType(struct_name, field, type_ref)

      {:SelectionType, _field_name, type_spec} ->
        fieldType(struct_name, field, type_spec)

      name when is_binary(name) ->
        res = builtin_map_lookup(name) || name

        if name in ["Sequence", "Choice", "UTF8String"] do
          IO.puts("Debug fieldType: name=#{inspect(name)} res=#{inspect(res)}")
        end

        res

      _ ->
        inspect(other)
    end
  end

  def fieldType(_struct_name, _field, other) when is_binary(other) do
    substituteType(other)
  end

  @impl true
  def array(name, type, tag_type, _level) do
    rust_name = name(name, getEnv(:current_module, ""))
    setEnv(name, rust_name)

    # We strip Vec<...> if it was added by sub-calls (unlikely for array call, but checking)
    inner_type =
      if String.starts_with?(type, "Vec<"), do: String.slice(type, 4..-2//1), else: type

    tag_identifier =
        if tag_type == :set do
            "ASN1Identifier::SET"
        else
            "ASN1Identifier::SEQUENCE"
        end

    body = """
    #{@generated_header}#{rust_use_block()}
    use super::*;
    use std::ops::Deref;

    #[derive(Debug, Clone)]
    pub struct #{rust_name}(pub Vec<#{inner_type}>);

    impl Deref for #{rust_name} {
        type Target = Vec<#{inner_type}>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
             // If inner type is ASN1Node, we collect manually
             #{if inner_type == "ASN1Node" do
      "if let rust_asn1::asn1::Content::Constructed(collection) = node.content { Ok(Self(collection.into_iter().collect())) } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())) }"
    else
      "let vec = rust_asn1::der::sequence_of(rust_asn1::asn1_types::#{tag_identifier}, node)?; Ok(Self(vec))"
    end}
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                #{tag_identifier},
                &|serializer: &mut Serializer| {
                    for item in &self.0 {
                        item.serialize(serializer)?;
                    }
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """

    save(true, getEnv(:current_module, ""), snake_case(rust_name), body)
    rust_name
  end

  @impl true
  defp flatten_target(modname) do
    case module_crate(modname) do
      "algorithminformation2009" -> ""
      _ -> modname
    end
  end

  @impl true
  def sequence(name, fields, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)
    setEnv(:current_struct, rust_name)

    contents =
      [
        @generated_header,
        rust_use_block(),
        emit_struct(rust_name, fields, modname),
        emit_constructor_block(rust_name, fields),
        emit_der_impls(rust_name, fields)
      ]
      |> Enum.join("\n")

    save(saveFlag, flatten_target(modname), snake_case(rust_name), contents)
  end

  @impl true
  def set(name, fields, modname, saveFlag), do: sequence(name, fields, modname, saveFlag)

  @impl true
  def choice(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_choice_variants(cases, rust_name, modname)}
      }

      #{emit_choice_der_impls(rust_name, cases)}
      """

    save(saveFlag, flatten_target(modname), snake_case(rust_name), body)
  end

  @impl true
  def enumeration(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    # Normalize cases to ensure they are all {name, value} tuples
    normalized_cases =
      cases
      |> Enum.reduce({0, []}, fn
        :EXTENSIONMARK, {idx, acc} ->
          {idx, [:EXTENSIONMARK | acc]}

        {:NamedNumber, n, v}, {_idx, acc} ->
          {v + 1, [{n, v} | acc]}

        {n, v}, {_idx, acc} ->
          {v + 1, [{n, v} | acc]}

        atom, {idx, acc} when is_atom(atom) ->
          {idx + 1, [{atom, idx} | acc]}

        other, {idx, acc} ->
          IO.puts("Warning: Unknown enum case format: #{inspect(other)}")
          {idx, acc}
      end)
      |> elem(1)
      |> Enum.reverse()

    body =
      """
        #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_enum_variants(normalized_cases)}
      }

      #{emit_enum_der_impls(rust_name, normalized_cases)}
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def integerEnum(name, cases, modname, saveFlag) do
    # Treat INTEGER variants as ENUMERATED for now in Rust binding
    enumeration(name, cases, modname, saveFlag)
  end

  @impl true
  def substituteType({:type, _, {:Externaltypereference, _, _, _} = ref, _, _, _}) do
    lookup_external(nil, nil, ref)
  end

  def substituteType({:pt, {:Externaltypereference, _, _, _} = ref, _args}) do
    lookup_external(nil, nil, ref)
  end

  def substituteType({:ObjectClassFieldType, _, _, _, _} = ocf) do
    fieldType(nil, nil, ocf)
  end

  def substituteType(type) do
    if match?({:ObjectClassFieldType, _, _, _, _}, type) do
      IO.puts("DEBUG substituteType MATCHED ObjectClassFieldType manually in fallback")
    else
      # Only log if it's NOT a binary (to avoid noise)
      if not is_binary(type) do
        IO.inspect(type, label: "DEBUG substituteType fallback")
      end
    end

    # Handle generic types recursively to avoid downcasing built-ins like Vec, Box, Option
    if is_binary(type) do
      cond do
        String.starts_with?(type, "Vec<") ->
          inner = String.slice(type, 4..-2//1)
          "Vec<" <> substituteType(inner) <> ">"

        String.starts_with?(type, "Box<") ->
          inner = String.slice(type, 4..-2//1)
          "Box<" <> substituteType(inner) <> ">"

        String.starts_with?(type, "Option<") ->
          inner = String.slice(type, 7..-2//1)
          "Option<" <> substituteType(inner) <> ">"

        true ->
          do_substitute(type)
      end
    else
      do_substitute(type)
    end
  end

  defp do_substitute(type) do
    type_name =
      case type do
        {:type, _, name, _, _, _} -> name
        name when is_atom(name) -> name
        name when is_binary(name) -> name
        _ -> nil
      end

    replacement =
      if type_name do
        type_name_str = to_string(type_name)

        # Global overrides from builtin_type_map take highest precedence
        res = builtin_map_lookup(type_name) || builtin_map_lookup(type_name_str)

        if type_name_str == "PKIX1Explicit2009AlgorithmIdentifier" do
          IO.puts("DEBUG: PKIX1Explicit2009AlgorithmIdentifier lookup res=#{inspect(res)}")
        end

        case res do
          val when not is_nil(val) ->
            # Track cross-crate dependency if the replacement contains a crate prefix (multi-crate only)
            if not is_single_crate?() and String.contains?(val, "::") do
              crate_name = String.split(val, "::") |> List.first()
              if crate_name != "crate", do: track_crate_dependency(crate_name)
            end

            val

          nil ->
            manual_map = %{
              "LDAPModifyRequestChangesSequenceOperationEnum" =>
                "LDAPModifyRequestChangesSequenceOperation",
              "LDAPResultResultCodeEnum" => "LDAPResultResultCode",
              "LDAPSearchRequestScopeEnum" => "LDAPSearchRequestScope",
              "LDAPSearchRequestDerefAliasesEnum" => "LDAPSearchRequestDerefAliases"
            }

            # Check for ASN1Node overrides from Application environment or lookup
            case is_asn1_node_type?(type_name_str) do
              true ->
                "ASN1Node"

              false ->
                val = Map.get(manual_map, type_name_str)

                if val do
                  # Track cross-crate dependency if the replacement contains a crate prefix
                  if String.contains?(val, "::") do
                    crate_name = String.split(val, "::") |> List.first()
                    if crate_name != "crate", do: track_crate_dependency(crate_name)
                  end

                  val
                else
                  current_module = getEnv(:current_module, "")
                  current_crate = module_crate(current_module)

                  prefixed =
                    if not is_single_crate?() and not String.contains?(type_name_str, "::") do
                      Enum.find_value(@modules, fn mod_canon ->
                        if String.starts_with?(type_name_str, mod_canon) do
                          crate = module_crate(mod_canon)
                          mod_field = fieldName(mod_canon)

                          if crate == current_crate do
                            if mod_canon == current_module do
                              type_name_str
                            else
                              "crate::#{mod_field}::#{type_name_str}"
                            end
                          else
                            track_crate_dependency(crate)
                            "#{crate}::#{mod_field}::#{type_name_str}"
                          end
                        end
                      end)
                    else
                      nil
                    end

                  case fetch_env_override(type_name) do
                    nil ->
                      prefixed || type_name_str

                    app_env_val ->
                      app_env_val
                  end
                end
            end
        end
      else
        nil
      end

    case replacement do
      nil ->
        if is_tuple(type) do
          # Prevent SystemLimitError by not returning complex tuples
          "Box<ASN1Node>"
        else
          type
        end

      r ->
        if is_binary(r) do
          # Aggressively strip any path and use crate:: in single-crate mode
          r =
            if is_single_crate?() and String.contains?(r, "::") do
              "crate::" <> (r |> String.split("::") |> List.last())
            else
              r
            end

          current_module = getEnv(:current_module, "")
          current_crate = module_crate(current_module)

          # Strip any leading 'crate::mod_field::' if it's redundant (same module)
          r =
            if String.starts_with?(r, "crate::") do
              mod_field = fieldName(current_module)

              if String.starts_with?(r, "crate::#{mod_field}::") do
                String.replace(r, "crate::#{mod_field}::", "")
              else
                r
              end
            else
              r
            end

          # Handle crate prefixes
          if String.contains?(r, "::") do
            parts = String.split(r, "::")
            [prefix | rest] = parts

            cond do
              prefix == "crate" ->
                r

              prefix == current_crate ->
                "crate::" <> Enum.join(rest, "::")

              # Unify crate names - using canonical names to avoid drift
              true ->
                final_crate = module_crate(prefix)

                if final_crate != current_crate and final_crate != "" do
                  if not Enum.member?(
                       ["std", "core", "rust_asn1", "dstu", "ldap", "x500", "upperbounds"],
                       final_crate
                     ) do
                    track_crate_dependency(final_crate)
                  end

                  "#{final_crate}::" <> Enum.join(rest, "::")
                else
                  r
                end
            end
          else
            r
          end
        else
          r
        end
    end
  end

  defp is_asn1_node_type?(type_name) do
    # Strip crate/module prefixes
    clean_name =
      if String.contains?(type_name, "::") do
        String.split(type_name, "::") |> List.last()
      else
        type_name
      end

    # Check if the type is explicitly mapped to ASN1Node in any module
    # We check both the raw name and modType patterns (without underscores, matching basic.ex)
    (Application.get_env(:asn1scg, String.to_atom(clean_name)) == "ASN1Node" ||
       Enum.any?(
         [
           "InformationFramework",
           "SelectedAttributeTypes",
           "AuthenticationFramework",
           "PKIX1Explicit88",
           "DSTU"
         ],
         fn mod ->
           Application.get_env(:asn1scg, String.to_atom("#{mod}#{clean_name}")) == "ASN1Node"
         end
       )) or clean_name == "AE-qualifier" or clean_name == "AP-title"
  end

  defp is_raw_node?(type) do
    # Only return true for the base type itself, not collections
    clean =
      if String.contains?(type, "::") do
        String.split(type, "::") |> List.last()
      else
        type
      end

    type == "ASN1Node" || type == "Box<ASN1Node>" || clean == "ASN1Node" ||
      (is_binary(type) &&
         (not String.contains?(type, "Vec<") and
            (String.contains?(type, "ASN1Node") or
               String.ends_with?(type, "APTitle") or
               String.ends_with?(type, "AEQualifier") or
               is_asn1_node_type?(type))))
  end

  defp is_single_crate?() do
    System.get_env("ASN1_SINGLE_CRATE") == "true" or
      :application.get_env(:asn1scg, :single_crate, false) == true
  end

  def tagClass(_tag), do: ""

  @impl true
  def typealias(name, target, modname, saveFlag) do
    rust_name = name(name, modname)
    target_name = substituteType(target)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      use super::*;

      pub type #{rust_name} = #{target_name};
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def value(_name, _type, _val, _modname, _saveFlag), do: []

  def sequenceOf(_name, _field, type), do: "Vec<#{substituteType(type)}>"

  # Region: emit helpers -----------------------------------------------------------

  defp emit_struct(rust_name, fields, modname) do
    field_lines =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_struct_field(rust_name, modname, &1))
      |> Enum.join("\n")

    """
    #{@default_derives}
    pub struct #{rust_name} {
    #{field_lines}
    }
    """
  end

  defp emit_struct_field(
         rust_name,
         modname,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    maybe_emit_nested_type(rust_name, field_name, type, modname)
    rust_field = pad_field_name(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "    pub #{rust_field}: #{final_type},"
  end

  defp emit_struct_field(_rust_name, _modname, _other), do: ""

  defp emit_constructor_block(rust_name, fields) do
    params =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_constructor_param(rust_name, &1))
      |> Enum.reject(&(&1 == ""))
      |> Enum.join(", ")

    assignments =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(fn {:ComponentType, _, field_name, _, _, _, _} ->
        fieldName(field_name)
      end)
      |> Enum.map(&"            #{&1},")
      |> Enum.join("\n")

    """
    impl #{rust_name} {
        pub fn new(#{params}) -> Self {
            Self {
    #{assignments}
            }
        }
    }
    """
  end

  defp emit_constructor_param(
         rust_name,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    rust_field = fieldName(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "#{rust_field}: #{final_type}"
  end

  defp emit_constructor_param(_rust_name, _other), do: ""

  defp emit_choice_variants(cases, rust_name, modname) do
    cases
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _, type, _, _, _}, _optional, _, _} ->
        maybe_emit_nested_type(rust_name, field_name, type, modname)
        variant_name = field_name |> raw_pascal() |> escape_reserved_variant()
        type_name = field_type_for(rust_name, field_name, type, [])

        "    #{variant_name}(#{type_name}),"

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_variants(cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "    #{variant} = #{val},"

      {name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "    #{variant} = #{val},"
    end)
    |> Enum.join("\n")
  end

  defp add_optional(type, :OPTIONAL), do: "Option<#{type}>"
  defp add_optional(type, _), do: type

  defp pad_field_name(name) do
    name
    |> fieldName()
    |> escape_reserved()
  end

  defp rust_use_block do
    """
    use std::sync::Arc;
    use rust_asn1::{
        asn1::ASN1Node,
        asn1_types::*,
        der::{self, DERParseable, DERSerializable, Serializer},
        errors::ASN1Error,
    };
    use bytes;
    use super::*;
    """
  end

  # Region: utilities --------------------------------------------------------------

  defp snake_case(value) do
    value
    |> String.replace("-", "")
    |> String.replace("_", "")
    |> Macro.underscore()
    |> String.replace("::", "_")
    |> String.replace("/", "_")
  end

  defp raw_pascal(value) do
    value
    |> bin()
    |> normalizeName()
    |> String.split(["_", "-", " ", "::", "/"], trim: true)
    |> Enum.map(&Macro.camelize/1)
    |> Enum.join("")
  end

  defp escape_reserved(name) do
    if name in @reserved_field_names do
      name <> "_"
    else
      name
    end
  end

  defp escape_reserved_variant(name) do
    if name in @reserved_variant_names do
      name <> "_"
    else
      name
    end
  end

  defp maybe_existing_atom(value) when is_atom(value), do: {:ok, value}

  defp maybe_existing_atom(value) when is_binary(value) do
    try do
      {:ok, String.to_existing_atom(value)}
    rescue
      ArgumentError -> :error
    end
  end

  defp maybe_existing_atom(string) do
    {:ok, String.to_atom(string)}
  rescue
    _ -> :error
  end

  defp builtin_map_lookup(key) when is_atom(key) do
    val = Map.get(@builtin_type_map, key)

    if val && is_single_crate?() && String.contains?(val, "::") do
      "crate::" <> (val |> String.split("::") |> List.last())
    else
      val
    end
  end

  defp builtin_map_lookup(key) when is_binary(key) do
    val =
      case maybe_existing_atom(key) do
        {:ok, atom} -> Map.get(@builtin_type_map, atom) || Map.get(@builtin_type_map, key)
        :error -> Map.get(@builtin_type_map, key)
      end

    if val && is_single_crate?() && String.contains?(val, "::") do
      "crate::" <> (val |> String.split("::") |> List.last())
    else
      val
    end
  end

  defp builtin_map_lookup(_key), do: nil

  defp fetch_env_override(type_name) when is_atom(type_name),
    do: Application.get_env(:asn1scg, type_name)

  defp fetch_env_override(type_name) when is_binary(type_name) do
    case maybe_existing_atom(type_name) do
      {:ok, atom} -> Application.get_env(:asn1scg, atom)
      :error -> nil
    end
  end

  defp fetch_env_override(_), do: nil

  defp lookup_builtin_or_external(name) do
    IO.puts("Lookup builtin/external: #{name}")

    case builtin_map_lookup(name) do
      nil ->
        try do
          res = lookup(normalizeName(name))

          if name == "UnauthAttributes" do
            IO.puts("DEBUG lookup UnauthAttributes: #{inspect(res)}")
          end

          res
        rescue
          _ -> name
        end

      mapped ->
        mapped
    end
  end

  defp lookup_external(_struct_name, _field, {:Externaltypereference, _, mod, type}) do
    mod_name = mod |> bin() |> normalizeName()
    type_name = name(type, mod)

    # Check for global overrides first (highest precedence)
    case builtin_map_lookup(type_name) do
      val when not is_nil(val) ->
        # Track cross-crate dependency (multi-crate only)
        if not is_single_crate?() and String.contains?(val, "::") do
          crate_name = String.split(val, "::") |> List.first()
          if crate_name != "crate", do: track_crate_dependency(crate_name)
        end

        val

      nil ->
        # Check if it should be an ASN1Node
        if is_asn1_node_type?(type_name) do
          "ASN1Node"
        else
          # Special case fix for S/MIME Capability naming mismatch if it occurs
          type_name =
            if String.ends_with?(type_name, "SMIMECAPS") and
                 not String.ends_with?(type_name, "SMIMECapabilities") do
              String.replace(type_name, "SMIMECAPS", "SMIMECapability")
            else
              type_name
            end

          external_crate = module_crate(mod_name)
          current_module = getEnv(:current_module, mod)
          current_crate = module_crate(current_module)
          module_field = fieldName(mod_name)

          if is_single_crate?() do
            # Single-crate flat mode: just use the type name directly
            # The file is in the same crate so we can just reference it
            type_name
          else
            prefix =
              if external_crate == current_crate do
                "crate"
              else
                # Track the cross-crate dependency
                track_crate_dependency(external_crate)
                external_crate
              end

            "#{prefix}::#{module_field}::#{type_name}"
          end
        end
    end
  end

  defp lookup_external(struct_name, field, other) do
    IO.puts("Lookup external fallback for #{inspect({struct_name, field})}: #{inspect(other)}")
    other |> bin() |> normalizeName()
  end

  defp ensure_generated_mod_entry(rust_name) do
    dir = outputDir()
    mod_dir = Path.expand(dir)
    File.mkdir_p!(mod_dir)
    mod_file = Path.join(mod_dir, "mod.rs")
    module_name = rust_name |> Macro.underscore() |> String.replace("/", "_")
    line = "pub mod #{module_name};\npub use self::#{module_name}::*;\n"

    cond do
      File.exists?(mod_file) ->
        existing = File.read!(mod_file)

        unless String.contains?(existing, line) do
          File.write!(mod_file, existing <> line)
        end

      true ->
        File.write!(mod_file, line)
    end
  end

  defp maybe_box(type, struct_name, field_name) do
    if is_boxed(struct_name, field_name) || type == struct_name do
      "Box<#{type}>"
    else
      type
    end
  end

  defp is_boxed(struct_name, field_name) do
    boxing = :application.get_env(:asn1scg, :boxing, [])
    # Use raw_pascal to match the keys in manual_boxing
    pascal_field = field_name |> bin() |> raw_pascal()
    key = "#{struct_name}.#{pascal_field}"
    # Special case for CHAT
    if key == "CHATMessage.Body", do: true, else: Enum.member?(boxing, key)
  end

  defp is_variant_boxed(enum_name, variant_name) do
    boxing = :application.get_env(:asn1scg, :boxing, [])

    # variant_name is already pascal-cased here because it's passed from emit_choice_variants/emit_enum_variants
    key = "#{enum_name}.#{variant_name}"
    Enum.member?(boxing, key)
  end

  defp emit_der_impls(rust_name, fields) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
    #{emit_sequence_decoder_body(rust_name, fields)}
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                ASN1Identifier::SEQUENCE,
                &|serializer: &mut Serializer| {
    #{emit_sequence_encoder_body(rust_name, fields)}
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """
  end

  defp emit_sequence_encoder_body(rust_name, fields) do
    fields
    |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
    |> Enum.map(&emit_struct_field_encoder(rust_name, &1))
    |> Enum.join("\n")
  end

  defp emit_struct_field_encoder(
         rust_name,
         {:ComponentType, _, field_name, {:type, tags, type, _, _, _}, optional, default, _}
       ) do
    rust_field = pad_field_name(field_name)
    field_access = "self.#{rust_field}"

    # Extract tag info
    tag_logic =
       case tags do
         [{:tag, class, number, method, _}] ->
             # class is :CONTEXT, :UNIVERSAL etc (atoms)
             # method is :IMPLICIT or :EXPLICIT
             # number is integer
             tag_class_str = case class do
                 :CONTEXT -> "TagClass::ContextSpecific"
                 :APPLICATION -> "TagClass::Application"
                 :PRIVATE -> "TagClass::Private"
                 :UNIVERSAL -> "TagClass::Universal"
                 _ -> "TagClass::ContextSpecific"
             end

             {tag_class_str, number, method}
         _ ->
             nil
       end

    # Define the serialization call for the value
    serialize_call =
        case tag_logic do
            nil ->
                "val.serialize(serializer)?;"

            {cls, num, method} when method == :EXPLICIT or method == {:default, :EXPLICIT} ->
                """
                serializer.append_constructed_node(
                    ASN1Identifier::new(#{num}, #{cls}),
                    &|s: &mut Serializer| val.serialize(s)
                )?;
                """

            {cls, num, method} when method == :IMPLICIT or method == {:default, :IMPLICIT} ->
                """
                {
                    let mut mh = Serializer::new();
                    val.serialize(&mut mh)?;
                    let mut bytes = mh.serialized_bytes().to_vec();
                    if bytes.len() > 0 {
                        let is_constructed = (bytes[0] & 0x20) != 0;
                        let tag_byte = 0x80 | (if is_constructed { 0x20 } else { 0 }) | (#{num} as u8);
                        bytes[0] = tag_byte;
                        let node = ASN1Node {
                            identifier: ASN1Identifier::new(#{num}, #{cls}),
                            encoded_bytes: bytes.into(),
                            content: rust_asn1::asn1::Content::Primitive(bytes::Bytes::new()),
                        };
                        node.serialize(serializer)?;
                    }
                }
                """
        end

    cond do
      optional == :OPTIONAL ->
        """
                    if let Some(val) = &#{field_access} {
                        #{serialize_call}
                    }
        """

      default != :asn1_NOVALUE ->
         # Handle DEFAULT
         """
                     // Default handling omitted for brevity, always serialize
                     #{String.replace(serialize_call, "val.", field_access <> ".")}
         """
         # Wait, if serialize_call uses 'val', we need to bind val, or replace usage.
         # For DEFAULT, the field is NOT Option (usually), so we access it directly.
         # For simplicity, if not Optional, we just serialize.

       true ->
         # Mandatory field
         # We need to wrap it in "let val = &self.field;" if we use serialize_call that assumes 'val'
         if tag_logic do
             """
             {
                 let val = &#{field_access};
                 #{serialize_call}
             }
             """
         else
             "#{field_access}.serialize(serializer)?;"
         end
    end
  end

  defp emit_struct_field_encoder(_rust_name, _other), do: ""

  @impl true
  def integerValue(name, value, modname, saveFlag) do
    rust_name = name(name, modname)

    val_str =
      case value do
        {:Externalvaluereference, _, mod, val_name} ->
          # Assuming the external module is imported or we can reference it fully qualified
          # For simplicity, let's try to map it to the generated name
          ref_mod_name = bin(mod) |> normalizeName()
          ref_val_name = bin(val_name)

          # If it's in the same "package" (x-series), the module name might need adjustment
          # referencing crate::generated::SnakeCaseMod::UpperVal

          mod_snake = snake_case(ref_mod_name)
          rust_val_name = name(ref_val_name, ref_mod_name)
          val_upper = String.upcase(rust_val_name)

          # We might need to ensure the module is public/accessible.
          # Generate a path or simple name
          # Manual value overrides
          value_map = %{
            "PKCS9UBNAME" => "crate::upper_bounds::upperboundsubname::UPPERBOUNDSUBNAME"
          }

          val_str =
            if Map.has_key?(value_map, val_upper) do
              Map.get(value_map, val_upper)
            else
              "crate::#{mod_snake}::#{val_upper}"
            end

          val_str =
            if is_single_crate?() and String.contains?(val_str, "::") do
              "crate::" <> (val_str |> String.split("::") |> List.last())
            else
              val_str
            end

        v when is_integer(v) ->
          "#{v}"

        _ ->
          # Fallback for other potential types, or error
          inspect(value)
      end

    const_body = """
    #{@generated_header}pub const #{String.upcase(rust_name)}: i64 = #{val_str};
    """

    save(saveFlag, modname, snake_case(rust_name), const_body)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:SEQUENCE, _, _, _, fields} = seq,
         modname
       ) do
    nested_name = fieldType(struct_name, field_name, seq) |> substituteType()
    sequence(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:SET, _, _, _, fields} = set_def, modname) do
    nested_name = fieldType(struct_name, field_name, set_def) |> substituteType()
    set(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:CHOICE, cases} = choice_def, modname) do
    nested_name = fieldType(struct_name, field_name, choice_def) |> substituteType()
    choice(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:ENUMERATED, cases} = enum_def, modname) do
    nested_name = fieldType(struct_name, field_name, enum_def) |> substituteType()
    enumeration(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SEQUENCE OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"Sequence Of", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SET OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(_struct_name, _field_name, _type, _modname), do: :ok

  defp emit_choice_der_impls(rust_name, cases) do
    # Generate arms with proper IMPLICIT tag swapping and EXPLICIT peeling
    arms =
      cases
      |> Enum.with_index()
      |> Enum.flat_map(fn
        {{:ComponentType, attrs, field_name, {:type, type_tags, type, _, _, _}, _optional, _, _}, idx} ->
          variant = field_name |> raw_pascal() |> escape_reserved_variant()
          type_name = field_type_for(rust_name, field_name, type, [])
          type_fish = String.replace(type_name, "<", "::<")

          # Determine tagging method from type_tags but always use idx for tag number
          tag_method = case type_tags do
            [{:tag, _class, _number, method, _}] -> method
            _ -> {:IMPLICIT, nil}  # Default to IMPLICIT
          end
          tag_method = case tag_method do
            {:IMPLICIT, _} -> :IMPLICIT
            {:EXPLICIT, _} -> :EXPLICIT
            {:default, :IMPLICIT} -> :IMPLICIT
            {:default, :EXPLICIT} -> :EXPLICIT
            other -> other
          end

          # Always use idx as the tag number for CHOICE alternatives to avoid duplicates
          tag_no = idx

          # Determine innermost universal tag for tag swapping
          universal_tag_no = universal_tag(type)

          # Generate the parsing call based on tagging method
          call = cond do
            is_raw_node?(type_name) ->
              "node"

            String.starts_with?(type_name, "Vec") ->
              elem_type = vector_element(type_name)
              if is_raw_node?(elem_type) do
                ~s|if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.into_iter().collect::<Vec<#{elem_type}>>() } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected constructed".to_string(), file!().to_string(), line!())); }|
              else
                "rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node)?"
              end

            String.starts_with?(type_name, "Box") ->
              inner = strip_generic(type_name, "Box<")
              inner_fish = String.replace(inner, "<", "::<")
              if is_raw_node?(inner) do
                "Box::new(node)"
              else
                "Box::new(#{inner_fish}::from_der_node(node)?)"
              end

            tag_method in [:EXPLICIT, {:default, :EXPLICIT}] ->
              # EXPLICIT: Peel outer tag to get inner node
              """
              {
                  if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                      let mut iter = collection.into_iter();
                      let inner_node = iter.next().ok_or(ASN1Error::new(
                          rust_asn1::errors::ErrorCode::InvalidASN1Object,
                          \"Expected inner node for Explicit #{variant}\".to_string(),
                          file!().to_string(),
                          line!(),
                      ))?;
                      #{type_fish}::from_der_node(inner_node)?
                  } else {
                      return Err(ASN1Error::new(
                          rust_asn1::errors::ErrorCode::UnexpectedFieldType,
                          \"Expected Constructed for Explicit #{variant}\".to_string(),
                          file!().to_string(),
                          line!(),
                      ));
                  }
              }
              """

            universal_tag_no != nil ->
              # IMPLICIT: Swap tag identifier before parsing
              """
              {
                  let mut node = node;
                  node.identifier = ASN1Identifier::new(#{universal_tag_no}, TagClass::Universal);
                  #{type_fish}::from_der_node(node)?
              }
              """

            true ->
              "#{type_fish}::from_der_node(node)?"
          end

          ["            (#{tag_no}, TagClass::ContextSpecific) => Ok(Self::#{variant}(#{call})),"]

        _ ->
          []
      end)
      |> Enum.join("\n")

    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            match (node.identifier.tag_number, node.identifier.tag_class) {
    #{arms}
                _ => Err(ASN1Error::new(
                    rust_asn1::errors::ErrorCode::UnexpectedFieldType,
                    format!(\"{}\", node.identifier),
                    file!().to_string(),
                    line!(),
                )),
            }
        }
    }

    #{emit_choice_encoder_body(rust_name, cases)}
    """
  end


  defp emit_choice_encoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _, type, _, _, _}, _optional, _, _} ->
        variant = field_name |> raw_pascal() |> escape_reserved_variant()
        type_name = field_type_for(rust_name, field_name, type, [])

        if String.starts_with?(type_name, "Vec<") do
          """
            #{rust_name}::#{variant}(val) => {
                for item in val {
                    item.serialize(serializer)?;
                }
                Ok(())
            }
          """
        else
          "            #{rust_name}::#{variant}(val) => val.serialize(serializer),"
        end

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_der_impls(rust_name, cases) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            let integer = ASN1Integer::from_der_node(node)?;
            // Attempt to convert BigInt to i64
            // ASN1Integer usually wraps BigInt in `value`.
            // We need to import TryInto or use a conversion method.
            // Using `TryInto` requires `use std::convert::TryInto;` in scope or prelude.
            // If `ASN1Integer` doesn't impl `TryInto<i64>`, maybe `integer.value` does.
            // Assuming `integer.value` is BigInt and `num_traits` or similar is available via `rust-asn1`.
            // If not available, we can try formatting to string and parsing (slow but robust fallback?).
            // Or assume `try_into` works on `value`.
            // Error said: `required for ASN1Integer to implement TryInto`. So `integer.try_into()` failed.
            // Let's try `integer.value.try_into()`.
            let val_res: Result<i64, _> = integer.value.try_into();
            let val = val_res.map_err(|_| ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Enum value out of range".to_string(), file!().to_string(), line!()))?;
            match val {
    #{emit_enum_decoder_cases(rust_name, cases)}
                _ => Err(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, format!("Unknown value for #{rust_name}: {}", val), file!().to_string(), line!()))
            }
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
             let val = self.clone() as i64;
             rust_asn1::asn1_types::ASN1Integer::from(val).serialize(serializer)?;
             Ok(())
        }
    }
    """
  end

  defp emit_choice_encoder_body(rust_name, cases) do
    use_context_tags = length(cases) > 1

    match_arms =
      cases
      |> Enum.with_index()
      |> Enum.map(fn
        {{:ComponentType, _, field_name, {:type, _, type, _, _, _}, _optional, _, _}, idx} ->
             variant = field_name |> raw_pascal() |> escape_reserved_variant()

             if use_context_tags do
                 if String.contains?(rust_name, "PKIBody") do
                   """
                               Self::#{variant}(val) => {
                                   serializer.append_constructed_node(
                                       ASN1Identifier::new(#{idx}, TagClass::ContextSpecific),
                                       &|s: &mut Serializer| val.serialize(s)
                                   )?;
                               },
                   """
                 else
                   # Implicit Tagging Logic
                   """
                               Self::#{variant}(val) => {
                                   let mut mh = Serializer::new();
                                   val.serialize(&mut mh)?;
                                   let mut bytes = mh.serialized_bytes().to_vec();
                                   if bytes.len() > 0 {
                                       let is_constructed = (bytes[0] & 0x20) != 0;
                                       let tag_byte = 0x80 | (if is_constructed { 0x20 } else { 0 }) | (#{idx} as u8);
                                       bytes[0] = tag_byte;
                                       let node = ASN1Node {
                                           identifier: ASN1Identifier::new(#{idx}, TagClass::ContextSpecific),
                                           encoded_bytes: bytes.into(),
                                           content: rust_asn1::asn1::Content::Primitive(bytes::Bytes::new()),
                                       };
                                       node.serialize(serializer)?;
                                   }
                               },
                   """
                 end
             else
                 "            Self::#{variant}(val) => val.serialize(serializer)?,"
             end

        _ -> ""
      end)
      |> Enum.join("\n")

    """
    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
             match self {
    #{match_arms}
             }
             Ok(())
        }
    }
    """
  end

  defp emit_enum_decoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{val} => Ok(#{rust_name}::#{variant}),"

      {name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{val} => Ok(#{rust_name}::#{variant}),"
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_encoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{rust_name}::#{variant} => #{val},"

      {name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{rust_name}::#{variant} => #{val},"
    end)
    |> Enum.join("\n")
  end

  defp emit_sequence_decoder_body(rust_name, fields) do
    decoders =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, {:type, attrs, type, _, _, _}, optional, _, _} ->
          rust_field = pad_field_name(field_name)
          field_type = field_type_for(rust_name, field_name, type, optional)
          _tag_no = tagNo(attrs)
          _tag_class = tagClass(attrs)

          type_fish = String.replace(field_type, "<", "::<")

          case optional do
            :OPTIONAL ->
              inner_type = field_type_for(rust_name, field_name, type, [])
              # field_type already contains Option<T>, so inner_type is T
              # We need to use inner_type for the actual parsing call
              inner_type_fish = String.replace(inner_type, "<", "::<")

              # Extract tag info for optional field matching
              {expected_tag_no, expected_tag_class, tag_method} = case attrs do
                [{:tag, class, number, method, _}] ->
                  cls = case class do
                    :CONTEXT -> "TagClass::ContextSpecific"
                    :APPLICATION -> "TagClass::Application"
                    :PRIVATE -> "TagClass::Private"
                    :UNIVERSAL -> "TagClass::Universal"
                    _ -> "TagClass::ContextSpecific"
                  end
                  {number, cls, method}
                _ ->
                  # No explicit tag, fallback to type check based on content
                  {nil, nil, nil}
              end

              if expected_tag_no != nil do
                # Has explicit tag: check tag before consuming
                if tag_method in [:EXPLICIT, {:default, :EXPLICIT}] do
                  # EXPLICIT: Peel the outer tag
                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    elem_type_fish = String.replace(elem_type, "<", "::<")
                    if is_raw_node?(elem_type) do
                      # Raw node elements - just collect
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  Some(seq_collection.into_iter().collect())
                                              } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())); }
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  Some(seq_collection.into_iter().map(|child| #{elem_type_fish}::from_der_node(child)).collect::<Result<_, _>>()?)
                                              } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())); }
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  else
                    # Non-Vec with EXPLICIT tag - check if raw node
                    if is_raw_node?(inner_type) do
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              Some(inner_node)
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              Some(#{inner_type_fish}::from_der_node(inner_node)?)
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  end
                else
                  # IMPLICIT: Check tag, swap identifier, then parse
                  universal_tag_no = universal_tag(type)
                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    elem_type_fish = String.replace(elem_type, "<", "::<")
                    # Check if element type is raw node
                    elem_call = if is_raw_node?(elem_type) do
                      "child"
                    else
                      "#{elem_type_fish}::from_der_node(child)?"
                    end
                    if is_raw_node?(elem_type) do
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              Some(collection.into_iter().collect())
                                          } else { None }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              Some(collection.into_iter().map(|child| #{elem_type_fish}::from_der_node(child)).collect::<Result<_, _>>()?)
                                          } else { None }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  else
                    # Single value - check if raw node
                    if is_raw_node?(inner_type) do
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          Some(nodes.next().unwrap())
                                      } else { None }
                                  } else { None };
                      """
                    else
                      swap_logic = if universal_tag_no != nil do
                        "let mut node = node; node.identifier = ASN1Identifier::new(#{universal_tag_no}, TagClass::Universal);"
                      else
                        ""
                      end
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          #{swap_logic}
                                          Some(#{inner_type_fish}::from_der_node(node)?)
                                      } else { None }
                                  } else { None };
                      """
                    end
                  end
                end
              else
                # No explicit tag - use existing type-based fallback logic
                if is_raw_node?(inner_type) or String.ends_with?(inner_type, "AttributeValue") do
                  "            let #{rust_field}: #{field_type} = nodes.next();"
                else
                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    if is_raw_node?(elem_type) do
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); Some(collection.clone().into_iter().collect::<Vec<#{elem_type}>>()) } else { None } } else { None };"
                    else
                      elem_type_fish = String.replace(elem_type, "<", "::<")
                      call = "#{elem_type_fish}::from_der_node(child)"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| #{call}).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };"
                    end
                  else
                    if String.starts_with?(inner_type, "Box<") do
                      inner = strip_generic(inner_type, "Box<")
                      inner_fish = String.replace(inner, "<", "::<")
                      call = if is_raw_node?(inner), do: "Ok(node.clone())", else: "#{inner_fish}::from_der_node(node.clone())"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { match #{call} { Ok(val) => { nodes.next(); Some(Box::new(val)) }, Err(_) => None } } else { None };"
                    else
                      call = if is_raw_node?(inner_type), do: "Ok(node.clone())", else: "#{inner_type_fish}::from_der_node(node.clone())"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { match #{call} { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };"
                    end
                  end
                end
              end


            _ ->
              type_fish = String.replace(field_type, "<", "::<")

              if String.starts_with?(field_type, "Vec") do
                elem_type = vector_element(field_type)

                if is_raw_node?(elem_type) do
                  "            let #{rust_field} = { let node = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?; if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.into_iter().collect::<Vec<#{elem_type}>>() } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())); } };"
                else
                  call = "#{elem_type}::from_der_node(child)"

                  "            let #{rust_field}: Vec<#{elem_type}> = { let node = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?; if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.clone().into_iter().map(|child| #{call}).collect::<Result<_, _>>()? } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())); } };"
                end
              else
                if is_raw_node?(field_type) or String.ends_with?(field_type, "AttributeValue") do
                  "            let #{rust_field} = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?;"
                else
                  if String.starts_with?(field_type, "Box<") do
                    inner = strip_generic(field_type, "Box<")

                    call =
                      if is_raw_node?(inner) do
                        "Ok(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)"
                      else
                        "#{inner}::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)"
                      end

                    "            let #{rust_field} = Box::new(#{call}?);"
                  else
                    call =
                      if is_raw_node?(type_fish) do
                        "nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?"
                      else
                        "#{type_fish}::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)?"
                      end

                    "            let #{rust_field} = #{call};"
                  end
                end
              end
          end

        _ ->
          ""
      end)
      |> Enum.join("\n")

    assignments =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, _, _, _, _} ->
          rust_field = pad_field_name(field_name)
          "                #{fieldName(field_name)}: #{rust_field},"

        _ ->
          ""
      end)
      |> Enum.join("\n")

    """
    #{decoders}
                Ok(Self {
    #{assignments}
                })
    """
  end

  defp emit_sequence_encoder_body(rust_name, fields) do
    fields
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _attrs, _type, _, _, _}, optional, _, _} ->
        rust_field = pad_field_name(field_name)

        case optional do
          :OPTIONAL ->
            "            if let Some(val) = &self.#{rust_field} { val.serialize(serializer)?; }"

          _ ->
            "            self.#{rust_field}.serialize(serializer)?;"
        end

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  # Helpers adapted from SwiftEmitter

  defp tagNo([]), do: nil
  defp tagNo(x) when is_integer(x), do: x
  defp tagNo([{:tag, _, nox, _, _}]), do: nox
  defp tagNo(_), do: nil

  defp universal_tag(type_ast) do
    case type_ast do
      :BOOLEAN -> 1
      :INTEGER -> 2
      {:INTEGER, _} -> 2
      :"BIT STRING" -> 3
      {:"BIT STRING", _} -> 3
      :"OCTET STRING" -> 4
      {:"OCTET STRING", _} -> 4
      :NULL -> 5
      :"OBJECT IDENTIFIER" -> 6
      :UTF8String -> 12
      :PrintableString -> 19
      :TeletexString -> 20
      :IA5String -> 22
      :UTCTime -> 23
      :GeneralizedTime -> 24
      :VisibleString -> 26
      {:VisibleString, _} -> 26
      :NumericString -> 18
      {:NumericString, _} -> 18
      :UniversalString -> 28
      :BMPString -> 30
      {:SEQUENCE, _, _, _, _} -> 16
      {:SET, _, _, _, _} -> 17
      {:"SEQUENCE OF", _} -> 16
      {:"SET OF", _} -> 17
      {:Externaltypereference, _, _, _} -> 16
      _ -> nil
    end
  end

  @impl true
  def tagClass([]), do: nil
  def tagClass(x) when is_integer(x), do: x
  def tagClass([{:tag, :CONTEXT, _, _, _}]), do: "TagClass::ContextSpecific"
  def tagClass([{:tag, :APPLICATION, _, _, _}]), do: "TagClass::Application"
  def tagClass([{:tag, :PRIVATE, _, _, _}]), do: "TagClass::Private"
  def tagClass([{:tag, :UNIVERSAL, _, _, _}]), do: "TagClass::Universal"
  def tagClass([{:tag, class, _, _, _}]), do: class

  defp tagNo_or_default(attrs) do
    case tagNo(attrs) do
      nil -> []
      val -> val
    end
  end

  def algorithmIdentifierClass(className, modname, saveFlag) do
    rust_name = name(className, modname)

    body = """
    #{@generated_header}#{rust_use_block()}
    #{@default_derives}
    pub struct #{rust_name} {
        pub algorithm: ASN1ObjectIdentifier,
        pub parameters: Option<ASN1Node>,
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
                let algorithm = ASN1ObjectIdentifier::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Missing algorithm".to_string(), file!().to_string(), line!()))?)?;
                let parameters = nodes.next();
                Ok(Self { algorithm, parameters })
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                ASN1Identifier::SEQUENCE,
                &|serializer: &mut Serializer| {
                    self.algorithm.serialize(serializer)?;
                    if let Some(params) = &self.parameters {
                         params.serialize(serializer)?;
                    }
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """

    save(saveFlag, modname, snake_case(rust_name), body)
  end
end
