defmodule ASN1.RustEmitter do
  IO.puts("Defining ASN1.RustEmitter module...")
  @behaviour ASN1.Emitter

  import ASN1,
    only: [bin: 1, normalizeName: 1, getEnv: 2, setEnv: 2, save: 4, lookup: 1, outputDir: 0]

  @reserved_field_names ~w(type self super Self crate use mod pub fn struct enum impl let mut ref loop match abstract async await become box const continue do dyn else extern false final for if in macro move override priv public pure return static trait true try typeof unsafe unsized virtual where while yield)
  @default_derives "#[derive(Clone, Debug)]"
  @generated_header "// Generated by ASN1.ERP.UNO Compiler -- Rust emitter" <> "\n"
  @reserved_variant_names ~w(Self)

  @builtin_type_map %{
    :"OBJECT IDENTIFIER" => "ASN1ObjectIdentifier",
    "OBJECT IDENTIFIER" => "ASN1ObjectIdentifier",
    :"BIT STRING" => "ASN1BitString",
    "BIT STRING" => "ASN1BitString",
    :"OCTET STRING" => "ASN1OctetString",
    "OCTET STRING" => "ASN1OctetString",
    :BOOLEAN => "ASN1Boolean",
    "BOOLEAN" => "ASN1Boolean",
    :INTEGER => "ASN1Integer",
    "INTEGER" => "ASN1Integer",
    :REAL => "ASN1Real",
    "REAL" => "ASN1Real",
    :ENUMERATED => "ASN1Integer",
    "ENUMERATED" => "ASN1Integer",
    :NULL => "ASN1Null",
    "NULL" => "ASN1Null",
    :UTF8String => "ASN1UTF8String",
    "UTF8String" => "ASN1UTF8String",
    :Printablestring => "ASN1PrintableString",
    "Printablestring" => "ASN1PrintableString",
    :PrintableString => "ASN1PrintableString",
    "PrintableString" => "ASN1PrintableString",
    :IA5String => "ASN1IA5String",
    "IA5String" => "ASN1IA5String",
    :NumericString => "ASN1NumericString",
    "NumericString" => "ASN1NumericString",
    :GeneralizedTime => "GeneralizedTime",
    "GeneralizedTime" => "GeneralizedTime",
    :UTCTime => "UTCTime",
    "UTCTime" => "UTCTime",
    :ANY => "ASN1Node",
    "ANY" => "ASN1Node",
    :ASN1Any => "ASN1Node",
    "ASN1Any" => "ASN1Node",
    # Mapped to OctetString or similar usually? rust_asn1 might not have it.
    :TeletexString => "ASN1UTF8String",
    "TeletexString" => "ASN1UTF8String",
    :BMPString => "ASN1UTF8String",
    "BMPString" => "ASN1UTF8String",
    :UniversalString => "ASN1UTF8String",
    "UniversalString" => "ASN1UTF8String",
    :GeneralString => "ASN1UTF8String",
    "GeneralString" => "ASN1UTF8String",
    :GraphicString => "ASN1UTF8String",
    "GraphicString" => "ASN1UTF8String",
    :VideotexString => "ASN1UTF8String",
    "VideotexString" => "ASN1UTF8String",
    :ObjectDescriptor => "ASN1UTF8String",
    "ObjectDescriptor" => "ASN1UTF8String",
    :VisibleString => "ASN1UTF8String",
    "VisibleString" => "ASN1UTF8String",
    # Generic handling
    :TYPE_IDENTIFIER => "ASN1Node",
    "TYPE-IDENTIFIER" => "ASN1Node",
    :Sequence => "ASN1Node",
    "Sequence" => "ASN1Node",
    :Choice => "ASN1Node",
    "Choice" => "ASN1Node",
    :Set => "ASN1Node",
    "Set" => "ASN1Node",
    :SET => "ASN1Node",
    "SET" => "ASN1Node",
    :ATTRIBUTE => "ASN1ObjectIdentifier",
    "ATTRIBUTE" => "ASN1ObjectIdentifier",
    "AttributeType" => "ASN1ObjectIdentifier",
    :AttributeType => "ASN1ObjectIdentifier",
    # Map AlgorithmIdentifier to the canonical version in algorithminformation2009
    "AlgorithmIdentifier" => "crate::AlgorithmInformation2009_Algorithm",
    :AlgorithmIdentifier => "crate::AlgorithmInformation2009_Algorithm",
    "PKIX1Explicit2009AlgorithmIdentifier" => "crate::AlgorithmInformation2009_Algorithm",
    "PKIX1Explicit2009Algorithm" => "crate::AlgorithmInformation2009_Algorithm",
    "AlgorithmInformation2009AlgorithmIdentifier" => "crate::AlgorithmInformation2009_Algorithm",
    "AlgorithmInformation2009Algorithm" => "crate::AlgorithmInformation2009_Algorithm",
    # SubjectPublicKeyInfo mappings
    "SubjectPublicKeyInfo" => "crate::PKIX1Explicit88_SubjectPublicKeyInfo",
    "PKCS10SubjectPublicKeyInfo" => "crate::PKIX1Explicit88_SubjectPublicKeyInfo",
    "InformationFrameworkATTRIBUTE" => "ASN1ObjectIdentifier",
    "ANSIX942AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "ANSIX942AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "ANSIX962AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "ANSIX962AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "AttributeCertificateVersion12009AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "CryptographicMessageSyntax2009Attribute" =>
      "crate::PKIXCommonTypes2009_Attribute",
    "CharacterPresentationAttributesCharacterAttributes" => "ASN1Node",
    "PKIXAttributeCertificate2009AttributeCertificate" =>
      "crate::AttributeCertificateVersion12009_AttributeCertificateV1",
    "CryptographicMessageSyntax2010AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::AlgorithmInformation2009_Algorithm",
    "TextUnitsTextUnit" => "crate::TextUnits_TextUnit",
    "StyleDescriptorsLayoutStyleDescriptor" =>
      "crate::StyleDescriptors_LayoutStyleDescriptor",
    "StyleDescriptorsPresentationStyleDescriptor" =>
      "crate::StyleDescriptors_PresentationStyleDescriptor",
    "SubprofilesSubprofileDescriptor" =>
      "crate::Subprofiles_SubprofileDescriptor",
    "PKCS10AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "CryptographicMessageSyntax2010ContentInfo" =>
      "crate::CryptographicMessageSyntax2010_ContentInfo",
    "PKIXCRMF2009PrivateKeyInfo" =>
      "crate::PKIXCRMF2009_PrivateKeyInfo",
    "PKCS8EncryptedPrivateKeyInfo" =>
      "crate::PKCS8_EncryptedPrivateKeyInfo",
    "PKCS7AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "PKCS7AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::AlgorithmInformation2009_Algorithm",
    "PKCS9DirectoryString" =>
      "crate::SelectedAttributeTypes_DirectoryString",
    "PKIX1Explicit2009AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "PKIX1Explicit88AuthenticationFrameworkAlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "PKCS5AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "CryptographicMessageSyntax2010Attribute" =>
      "crate::PKIXCommonTypes2009_Attribute",
    "PKIXAttributeCertificate2009AlgorithmIdentifier" =>
      "crate::AuthenticationFramework_AlgorithmIdentifier",
    "AttributeType" => "ASN1ObjectIdentifier",
    "ContentType" => "ASN1ObjectIdentifier",
    "PKCS7ContentType" => "ASN1ObjectIdentifier",
    "PKCS9ContentType" => "ASN1ObjectIdentifier",
    "CryptographicMessageSyntax2009ContentType" => "ASN1ObjectIdentifier",
    "ExtendedSecurityServices2009ContentType" => "ASN1ObjectIdentifier",
    "StyleDescriptorsContentType" => "crate::StyleDescriptors_ContentType",
    "AP-title" => "ASN1Node",
    "AE-qualifier" => "ASN1Node",
    "DORDefinitionAPTitle" => "ASN1Node",
    "DORDefinitionAEQualifier" => "ASN1Node",
    "CharacterProfileAttributesCharacterContentDefaults" => "ASN1Node",
    "RasterGrProfileAttributesRasterGrContentDefaults" => "ASN1Node",
    "GeoGrProfileAttributesGeoGrContentDefaults" => "ASN1Node",
    "DocumentProfileDescriptorDateAndTime" =>
      "crate::DocumentProfileDescriptor_DateAndTime",
    "CryptographicMessageSyntax2010IssuerAndSerialNumber" =>
      "crate::CryptographicMessageSyntax2010_IssuerAndSerialNumber",
    "LinkDescriptorsLinkClassDescriptor" =>
      "crate::LinkDescriptors_LinkClassDescriptor",
    "LinkDescriptorsLinkDescriptor" =>
      "crate::LinkDescriptors_LinkDescriptor",
    # ORAddress mappings
    "ORAddress" => "ASN1Node",
    "PKIX1Explicit2009ORAddress" => "ASN1Node",
    # Final cleanup mappings
    "EXTERNAL" => "ASN1Node",
    :EXTERNAL => "ASN1Node",
    "AttributeCertificateVersion12009AttributeCertificateV1" => "ASN1Node",
    "KEPTime" => "crate::AuthenticationFramework_Time",
    "CryptographicMessageSyntax2009AlgorithmInformation2009AlgorithmIdentifier" =>
      "crate::AlgorithmInformation2009_Algorithm",
    # Extension and Attributes types - use ASN1Node for byte preservation (avoid parsing issues)
    "AuthenticationFrameworkExtension" => "ASN1Node",
    "AuthenticationFrameworkExtensions" => "Vec<ASN1Node>",
    "Extension" => "ASN1Node",
    "Extensions" => "Vec<ASN1Node>",
    "CertificateExtensionsExtension" => "ASN1Node",
    "AuthenticationFrameworkVersion" => "ASN1Node",
    "PKCS10Attributes" => "Vec<ASN1Node>",
    "PKCS10Attribute" => "ASN1Node",
    # ToBeSigned types - use ASN1Node as generated serialization loses structure
    "AuthenticationFrameworkCertificateToBeSigned" => "ASN1Node",
    "AuthenticationFrameworkTBSCertificate" => "ASN1Node"
  }

  # Region: behaviour callbacks ----------------------------------------------------

  @modules [
    "PKIX1Explicit88",
    "PKIX1Implicit2009",
    "PKIX1Explicit2009",
    "PKIXCommonTypes2009",
    "AuthenticationFramework",
    "CertificateExtensions",
    "DirectoryAbstractService",
    "UsefulDefinitions",
    "DSTU",
    "LDAP",
    "AlgorithmInformation2009",
    "InformationFramework",
    "SelectedAttributeTypes"
  ]

  @impl true
  def fileExtension, do: ".rs"

  @impl true
  def builtinType(type) when is_atom(type) do
    Map.get(@builtin_type_map, type, "ASN1Node")
  end


  defp vector_element(vec_type) when is_binary(vec_type) do
    vec_type
    |> strip_generic("Box<")
    |> strip_generic("Vec<")
    |> String.trim()
  end

  defp strip_generic(type, prefix) do
    if String.starts_with?(type, prefix) and String.ends_with?(type, ">") do
      prefix_len = String.length(prefix)
      String.slice(type, prefix_len..-2//1)
    else
      type
    end
  end

  defp field_type_for(struct_name, field, type, optional) do
    type_name = fieldType(struct_name, field, type)

    base_type =
      type_name
      |> substituteType()
      |> maybe_box(struct_name, field)

    # Ensure internal types have crate:: prefix in single-crate mode
    final_base =
      if not String.contains?(base_type, "::") and
           not is_primitive_or_std_type?(base_type) do
        if String.starts_with?(base_type, "Box<") do
          # Extract inner type, prefix it, and re-wrap
          inner = String.slice(base_type, 4..-2//1)
          "Box<crate::#{inner}>"
        else
          "crate::" <> base_type
        end
      else
        base_type
      end

    if optional == :OPTIONAL do
      "Option<" <> final_base <> ">"
    else
      final_base
    end
  end

  defp is_primitive_or_std_type?(type) do
    # Trim and handle Option wrappers
    clean = type |> String.replace("Option<", "") |> String.replace(">", "") |> String.trim()

    res =
      Enum.member?(
        [
          "ASN1Integer",
          "ASN1BitString",
          "ASN1OctetString",
          "ASN1ObjectIdentifier",
          "ASN1Boolean",
          "ASN1Null",
          "ASN1Enumerated",
          "ASN1UTF8String",
          "ASN1IA5String",
          "ASN1PrintableString",
          "ASN1NumericString",
          "ASN1TeletexString",
          "ASN1UniversalString",
          "ASN1UTCTime",
          "ASN1GeneralizedTime",
          "ASN1Node",
          "ASN1Any",
          "f64",
          "i32",
          "i64",
          "u32",
          "bool",
          "GeneralizedTime",
          "UTCTime",
          "ObjectDescriptor",
          "ASN1Real",
          "ASN1BMPString",
          "ASN1GeneralString",
          "ASN1VisibleString",
          "ASN1GraphicString",
          "ASN1T61String",
          "ASN1ObjectDescriptor"
        ],
        clean
      ) or String.starts_with?(clean, "Vec<") or String.starts_with?(clean, "Box<") or
        clean == "ASN1Node"

    res
  end

  @impl true
  def name(raw_name, modname) do
    pascal_mod = raw_pascal(modname)
    pascal_type = raw_pascal(raw_name)

    # Consolidate SMIMECAPS fix here
    pascal_type =
      if String.ends_with?(pascal_type, "SMIMECAPS") and
           not String.ends_with?(pascal_type, "SMIMECapabilities") do
        String.replace(pascal_type, "SMIMECAPS", "SMIMECapability")
      else
        pascal_type
      end

    # Fix for AlgorithmIdentifier being renamed to Algorithm in AlgorithmInformation2009
    pascal_type =
      if String.downcase(pascal_mod) == "algorithminformation2009" and
           pascal_type == "AlgorithmIdentifier" do
        "Algorithm"
      else
        # Fix for PKCS5 AlgorithmIdentifier casing
        if String.upcase(pascal_mod) == "PKCS5" and
             String.upcase(pascal_type) == "ALGORITHMIDENTIFIER" do
          "AlgorithmIdentifier"
        else
          pascal_type
        end
      end

    # Always prefix with module name to avoid collisions
    # e.g., CHAT module: Message -> CHAT_Message, CHATMessage -> CHAT_CHATMessage
    res = pascal_mod <> "_" <> pascal_type

    # Ensure no :: in type names if they are being used for definitions
    res |> String.replace("::", "_") |> String.replace("/", "_")
  end

  defp canonical_module_name(modname) do
    modname
    |> bin()
    |> normalizeName()
    |> String.replace("-", "")
    |> String.replace("_", "")
    |> String.replace(".", "")
  end

  @impl true
  def fieldName(name) do
    name
    |> normalizeName()
    |> snake_case()
    |> escape_reserved()
  end

  @impl true
  def fieldType(struct_name, field, {:type, _, inner, _, _, _}) do
    fieldType(struct_name, field, inner)
  end

  def fieldType(struct_name, field, {:pt, {:Externaltypereference, _, _, _} = ref, _args}) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, {:ObjectClassFieldType, _, _, fields, _})
      when is_list(fields) do
    case Keyword.get(fields, :valuefieldreference) do
      :id -> "ASN1ObjectIdentifier"
      _ -> "ASN1Node"
    end
  end

  def fieldType(struct_name, field, {:ObjectClassFieldType, _, _, fields, _}) do
    IO.puts("DEBUG ObjectClassFieldType fields=#{inspect(fields)}")

    cond do
      fields == :id -> "ASN1ObjectIdentifier"
      match?({:valuefieldreference, :id}, fields) -> "ASN1ObjectIdentifier"
      true -> "ASN1Node"
    end
  end

  def fieldType(_struct_name, _field, {:"SEQUENCE OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(_struct_name, _field, {:"SET OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(struct_name, field, {:"Sequence Of", inner}) do
    fieldType(struct_name, field, {:"SEQUENCE OF", inner})
  end

  def fieldType(struct_name, field, {:"Set Of", inner}) do
    fieldType(struct_name, field, {:"SET OF", inner})
  end

  def fieldType(struct_name, field, {:Externaltypereference, _, _, _} = ref) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, atom) when is_atom(atom) do
    atom
    |> Atom.to_string()
    |> lookup_builtin_or_external()
  end

  def fieldType(struct_name, field, other) when is_tuple(other) do
    case other do
      {:CHOICE, _} ->
        name("#{field}_choice", struct_name)

      {:SEQUENCE, _, _, _, _} ->
        name("#{field}_sequence", struct_name)

      {:SET, _, _, _, _} ->
        name("#{field}_set", struct_name)

      {:ENUMERATED, _} ->
        name("#{field}_enum", struct_name)

      {:ANY_DEFINED_BY, _} ->
        "ASN1Node"

      {:INTEGER, _} ->
        "ASN1Integer"

      {:"BIT STRING", _} ->
        "ASN1BitString"

      {:"INSTANCE OF", _, _} ->
        "ASN1Node"

      {:SelectionType, _field_name, {:type, _, type_ref, _, _, _}} ->
        fieldType(struct_name, field, type_ref)

      {:SelectionType, _field_name, type_spec} ->
        fieldType(struct_name, field, type_spec)

      name when is_binary(name) ->
        res = builtin_map_lookup(name) || name

        if name in ["Sequence", "Choice", "UTF8String"] do
          IO.puts("Debug fieldType: name=#{inspect(name)} res=#{inspect(res)}")
        end

        res

      _ ->
        inspect(other)
    end
  end

  def fieldType(_struct_name, _field, other) when is_binary(other) do
    substituteType(other)
  end

  @impl true
  def module_crate(_modname) do
    "asn1_suite"
  end

  def module_crate_internal(modname) do
    canon = canonical_module_name(modname)

    if String.contains?(canon, "Algorithm") or String.contains?(canon, "PKIX") do
      "x500"
    else
      case canon do
        "InformationFramework" ->
          "x500"

        "SelectedAttributeTypes" ->
          "x500"

        "DirectoryAbstractService" ->
          "x500"

        "UsefulDefinitions" ->
          "x500"

        "CertificateExtensions" ->
          "x500"

        "AuthenticationFramework" ->
          "x500"

        "DSTU" ->
          "dstu"

        "AlgorithmInformation2009" ->
          "algorithminformation2009"

        "PKIX1Explicit88" ->
          "pkix1explicit88"

        "PKIX1Explicit2009" ->
          "pkix1explicit2009"

        "PKIX1Implicit2009" ->
          "pkix1implicit2009"

        "PKIXCommonTypes2009" ->
          "pkixcommontypes2009"

        "LDAP" ->
          "ldap"

        other ->
          if other == "" do
            ""
          else
            other
            |> String.downcase()
          end
      end
    end
  end

  @doc """
  Track a cross-crate dependency. Called during code generation when
  a type from an external crate is referenced.
  """
  def track_crate_dependency(external_crate) do
    current_module = getEnv(:current_module, "")
    current_crate = module_crate(current_module)

    if external_crate != nil and external_crate != current_crate and external_crate != "" do
      key = {:crate_deps, current_crate}
      existing = :application.get_env(:asn1scg, key, MapSet.new())
      updated = MapSet.put(existing, external_crate)
      :application.set_env(:asn1scg, key, updated)
    end
  end

  @doc """
  Get tracked cross-crate dependencies for a given crate.
  Returns a list of crate names that the given crate depends on.
  """
  def get_crate_dependencies(crate) do
    :application.get_env(:asn1scg, {:crate_deps, crate}, MapSet.new())
    |> MapSet.to_list()
  end


  @impl true
  def array(name, type, tag_type, _level) do
    rust_name = name(name, getEnv(:current_module, ""))
    setEnv(name, rust_name)

    # We strip Vec<...> if it was added by sub-calls (unlikely for array call, but checking)
    inner_type =
      if String.starts_with?(type, "Vec<"), do: String.slice(type, 4..-2//1), else: type

    tag_identifier =
        if tag_type == :set do
            "ASN1Identifier::SET"
        else
            "ASN1Identifier::SEQUENCE"
        end

    body = """
    #{@generated_header}#{rust_use_block()}
    use super::*;
    use std::ops::Deref;

    #[derive(Debug, Clone)]
    pub struct #{rust_name}(pub Vec<#{inner_type}>);

    impl Deref for #{rust_name} {
        type Target = Vec<#{inner_type}>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
             // If inner type is ASN1Node, we collect manually
             #{if inner_type == "ASN1Node" do
      "if let rust_asn1::asn1::Content::Constructed(collection) = node.content { Ok(Self(collection.into_iter().collect())) } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())) }"
    else
      "let vec = rust_asn1::der::sequence_of(rust_asn1::asn1_types::#{tag_identifier}, node)?; Ok(Self(vec))"
    end}
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                #{tag_identifier},
                &|serializer: &mut Serializer| {
                    for item in &self.0 {
                        item.serialize(serializer)?;
                    }
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """

    save(true, getEnv(:current_module, ""), snake_case(rust_name), body)
    rust_name
  end

  @impl true
  defp flatten_target(modname) do
    case module_crate(modname) do
      "algorithminformation2009" -> ""
      _ -> modname
    end
  end

  @impl true
  def sequence(name, fields, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)
    setEnv(:current_struct, rust_name)

    contents =
      [
        @generated_header,
        rust_use_block(),
        emit_struct(rust_name, fields, modname),
        emit_constructor_block(rust_name, fields),
        emit_der_impls(rust_name, fields)
      ]
      |> Enum.join("\n")

    save(saveFlag, flatten_target(modname), snake_case(rust_name), contents)
  end

  @impl true
  def set(name, fields, modname, saveFlag), do: sequence(name, fields, modname, saveFlag)

  @impl true
  def choice(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_choice_variants(cases, rust_name, modname)}
      }

      #{emit_choice_der_impls(rust_name, cases)}
      """

    save(saveFlag, flatten_target(modname), snake_case(rust_name), body)
  end

  @impl true
  def enumeration(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    # Normalize cases to ensure they are all {name, value} tuples
    normalized_cases =
      cases
      |> Enum.reduce({0, []}, fn
        :EXTENSIONMARK, {idx, acc} ->
          {idx, [:EXTENSIONMARK | acc]}

        {:NamedNumber, n, v}, {_idx, acc} ->
          {v + 1, [{n, v} | acc]}

        {n, v}, {_idx, acc} ->
          {v + 1, [{n, v} | acc]}

        atom, {idx, acc} when is_atom(atom) ->
          {idx + 1, [{atom, idx} | acc]}

        other, {idx, acc} ->
          IO.puts("Warning: Unknown enum case format: #{inspect(other)}")
          {idx, acc}
      end)
      |> elem(1)
      |> Enum.reverse()

    body =
      """
        #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_enum_variants(normalized_cases)}
      }

      #{emit_enum_der_impls(rust_name, normalized_cases)}
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def integerEnum(name, cases, modname, saveFlag) do
    # Treat INTEGER variants as ENUMERATED for now in Rust binding
    enumeration(name, cases, modname, saveFlag)
  end

  @impl true
  def substituteType({:type, _, {:Externaltypereference, _, _, _} = ref, _, _, _}) do
    lookup_external(nil, nil, ref)
  end

  def substituteType({:pt, {:Externaltypereference, _, _, _} = ref, _args}) do
    lookup_external(nil, nil, ref)
  end

  def substituteType({:ObjectClassFieldType, _, _, _, _} = ocf) do
    fieldType(nil, nil, ocf)
  end

  def substituteType(type) do
    if match?({:ObjectClassFieldType, _, _, _, _}, type) do
      IO.puts("DEBUG substituteType MATCHED ObjectClassFieldType manually in fallback")
    else
      # Only log if it's NOT a binary (to avoid noise)
      if not is_binary(type) do
      end
    end

    # Handle generic types recursively to avoid downcasing built-ins like Vec, Box, Option
    if is_binary(type) do
      cond do
        String.starts_with?(type, "Vec<") ->
          inner = String.slice(type, 4..-2//1)
          "Vec<" <> substituteType(inner) <> ">"

        String.starts_with?(type, "Box<") ->
          inner = String.slice(type, 4..-2//1)
          "Box<" <> substituteType(inner) <> ">"

        String.starts_with?(type, "Option<") ->
          inner = String.slice(type, 7..-2//1)
          "Option<" <> substituteType(inner) <> ">"

        true ->
          do_substitute(type)
      end
    else
      do_substitute(type)
    end
  end

  defp do_substitute(type) do
    type_name =
      case type do
        {:type, _, name, _, _, _} -> name
        name when is_atom(name) -> name
        name when is_binary(name) -> name
        _ -> nil
      end

    replacement =
      if type_name do
        type_name_str = to_string(type_name)

        # Global overrides from builtin_type_map take highest precedence
        res = builtin_map_lookup(type_name) || builtin_map_lookup(type_name_str)

        if type_name_str == "PKIX1Explicit2009AlgorithmIdentifier" do
        end

        case res do
          val when not is_nil(val) ->
            # Track cross-crate dependency if the replacement contains a crate prefix (multi-crate only)
            if String.contains?(val, "::") do
              crate_name = String.split(val, "::") |> List.first()
              if crate_name != "crate", do: track_crate_dependency(crate_name)
            end

            val

          nil ->
            manual_map = %{
              "LDAPModifyRequestChangesSequenceOperationEnum" =>
                "LDAPModifyRequestChangesSequenceOperation",
              "LDAPResultResultCodeEnum" => "LDAPResultResultCode",
              "LDAPSearchRequestScopeEnum" => "LDAPSearchRequestScope",
              "LDAPSearchRequestDerefAliasesEnum" => "LDAPSearchRequestDerefAliases"
            }

            # Check for ASN1Node overrides from Application environment or lookup
            case is_asn1_node_type?(type_name_str) do
              true ->
                "ASN1Node"

              false ->
                val = Map.get(manual_map, type_name_str)

                if val do
                  # Track cross-crate dependency if the replacement contains a crate prefix
                  if String.contains?(val, "::") do
                    crate_name = String.split(val, "::") |> List.first()
                    if crate_name != "crate", do: track_crate_dependency(crate_name)
                  end

                  val
                else
                  current_module = getEnv(:current_module, "")
                  current_crate = module_crate(current_module)

                  prefixed = type_name_str

                  case fetch_env_override(type_name) do
                    nil ->
                      prefixed || type_name_str

                    app_env_val ->
                      app_env_val
                  end
                end
            end
        end
      else
        nil
      end

    case replacement do
      nil ->
        if is_tuple(type) do
          # Prevent SystemLimitError by not returning complex tuples
          "Box<ASN1Node>"
        else
          type
        end

      r ->
        if is_binary(r) do
          # Aggressively strip any path and use crate:: in single-crate mode
          r =
            if String.contains?(r, "::") do
              "crate::" <> (r |> String.split("::") |> List.last())
            else
              r
            end

          current_module = getEnv(:current_module, "")
          current_crate = module_crate(current_module)

          # Strip any leading 'crate::mod_field::' if it's redundant (same module)
          r =
            if String.starts_with?(r, "crate::") do
              mod_field = fieldName(current_module)

              if String.starts_with?(r, "crate::#{mod_field}::") do
                String.replace(r, "crate::#{mod_field}::", "")
              else
                r
              end
            else
              r
            end

          # Handle crate prefixes
          if String.contains?(r, "::") do
            parts = String.split(r, "::")
            [prefix | rest] = parts

            cond do
              prefix == "crate" ->
                r

              prefix == current_crate ->
                "crate::" <> Enum.join(rest, "::")

              # Unify crate names - using canonical names to avoid drift
              true ->
                final_crate = module_crate(prefix)

                if final_crate != current_crate and final_crate != "" do
                  if not Enum.member?(
                       ["std", "core", "rust_asn1", "dstu", "ldap", "x500", "upperbounds"],
                       final_crate
                     ) do
                    track_crate_dependency(final_crate)
                  end

                  "#{final_crate}::" <> Enum.join(rest, "::")
                else
                  r
                end
            end
          else
            r
          end
        else
          r
        end
    end
  end

  defp is_asn1_node_type?(type_name) do
    # Strip crate/module prefixes
    clean_name =
      if String.contains?(type_name, "::") do
        String.split(type_name, "::") |> List.last()
      else
        type_name
      end

    # Explicitly known ASN1Node aliases (ANY types)
    # We must be careful not to match generated structs (like SelectedAttributeTypesASN1Node)
    clean_name == "InformationFrameworkAttributeType" ||
    clean_name == "AttributeValue" ||
    (Application.get_env(:asn1scg, String.to_atom(clean_name)) == "ASN1Node" ||
       Enum.any?(
         [
           "InformationFramework",
           "SelectedAttributeTypes",
           "AuthenticationFramework",
           "PKIX1Explicit88",
           "DSTU"
         ],
         fn mod ->
           Application.get_env(:asn1scg, String.to_atom("#{mod}#{clean_name}")) == "ASN1Node"
         end
       )) or clean_name == "AE-qualifier" or clean_name == "AP-title"
  end

  defp is_raw_node?(type) do
    if String.contains?(type, "LocationExpressionsASN1Node") do
    end
    # Only return true for the base type itself, not collections
    clean =
      if String.contains?(type, "::") do
        String.split(type, "::") |> List.last()
      else
        type
      end

    type == "ASN1Node" || type == "Box<ASN1Node>" || clean == "ASN1Node" ||
      (is_binary(type) &&
         (not String.contains?(type, "Vec<") and
             (String.ends_with?(type, "APTitle") or
               String.ends_with?(type, "AEQualifier") or
               is_asn1_node_type?(type))))
  end


  def tagClass([{:tag, class, _, _, _}]), do: class
  def tagClass(x) when is_integer(x), do: x
  def tagClass([{:tag, :CONTEXT, _, _, _}]), do: "TagClass::ContextSpecific"
  def tagClass([{:tag, :APPLICATION, _, _, _}]), do: "TagClass::Application"
  def tagClass([{:tag, :PRIVATE, _, _, _}]), do: "TagClass::Private"
  def tagClass([{:tag, :UNIVERSAL, _, _, _}]), do: "TagClass::Universal"
  def tagClass(_tag), do: nil

  @impl true
  def typealias(name, target, modname, saveFlag) do
    rust_name = name(name, modname)
    target_name = substituteType(target)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      use super::*;

      pub type #{rust_name} = #{target_name};
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def value(_name, _type, _val, _modname, _saveFlag), do: []

  def sequenceOf(_name, _field, type), do: "Vec<#{substituteType(type)}>"

  # Region: emit helpers -----------------------------------------------------------

  defp emit_struct(rust_name, fields, modname) do
    field_lines =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_struct_field(rust_name, modname, &1))
      |> Enum.join("\n")

    """
    #{@default_derives}
    pub struct #{rust_name} {
    #{field_lines}
    }
    """
  end

  defp emit_struct_field(
         rust_name,
         modname,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    maybe_emit_nested_type(rust_name, field_name, type, modname)
    rust_field = pad_field_name(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "    pub #{rust_field}: #{final_type},"
  end

  defp emit_struct_field(_rust_name, _modname, _other), do: ""

  defp emit_constructor_block(rust_name, fields) do
    params =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_constructor_param(rust_name, &1))
      |> Enum.reject(&(&1 == ""))
      |> Enum.join(", ")

    assignments =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(fn {:ComponentType, _, field_name, _, _, _, _} ->
        fieldName(field_name)
      end)
      |> Enum.map(&"            #{&1},")
      |> Enum.join("\n")

    """
    impl #{rust_name} {
        pub fn new(#{params}) -> Self {
            Self {
    #{assignments}
            }
        }
    }
    """
  end

  defp emit_constructor_param(
         rust_name,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    rust_field = fieldName(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "#{rust_field}: #{final_type}"
  end

  defp emit_constructor_param(_rust_name, _other), do: ""

  defp emit_choice_variants(cases, rust_name, modname) do
    cases
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _, type, _, _, _}, _optional, _, _} ->
        maybe_emit_nested_type(rust_name, field_name, type, modname)
        variant_name = field_name |> raw_pascal() |> escape_reserved_variant()
        type_name = field_type_for(rust_name, field_name, type, [])

        "    #{variant_name}(#{type_name}),"

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_variants(cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "    #{variant} = #{val},"

      {name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "    #{variant} = #{val},"
    end)
    |> Enum.join("\n")
  end

  defp add_optional(type, _), do: type

  defp pad_field_name(name) do
    name
    |> fieldName()
    |> escape_reserved()
  end

  defp rust_use_block do
    """
    use std::sync::Arc;
    use rust_asn1::{
        asn1::ASN1Node,
        asn1_types::*,
        der::{self, DERParseable, DERSerializable, Serializer},
        errors::ASN1Error,
    };
    use bytes;
    use super::*;
    """
  end

  # Region: utilities --------------------------------------------------------------

  defp snake_case(value) do
    value
    |> String.replace("-", "_")
    |> Macro.underscore()
    |> String.replace("::", "_")
    |> String.replace("/", "_")
  end

  defp raw_pascal(value) do
    value
    |> bin()
    |> normalizeName()
    |> String.split(["_", "-", " ", "::", "/"], trim: true)
    |> Enum.map(&Macro.camelize/1)
    |> Enum.join("")
  end

  defp escape_reserved(name) do
    if name in @reserved_field_names do
      name <> "_"
    else
      name
    end
  end

  defp escape_reserved_variant(name) do
    if name in @reserved_variant_names do
      name <> "_"
    else
      name
    end
  end

  defp maybe_existing_atom(value) when is_atom(value), do: {:ok, value}

  defp maybe_existing_atom(value) when is_binary(value) do
    try do
      {:ok, String.to_existing_atom(value)}
    rescue
      ArgumentError -> :error
    end
  end

  defp maybe_existing_atom(string) do
    {:ok, String.to_atom(string)}
  rescue
    _ -> :error
  end

  defp builtin_map_lookup(key) when is_atom(key) do
    val = Map.get(@builtin_type_map, key)

    if val && String.contains?(val, "::") do
      "crate::" <> (val |> String.split("::") |> List.last())
    else
      val
    end
  end

  defp builtin_map_lookup(key) when is_binary(key) do
    val =
      case maybe_existing_atom(key) do
        {:ok, atom} -> Map.get(@builtin_type_map, atom) || Map.get(@builtin_type_map, key)
        :error -> Map.get(@builtin_type_map, key)
      end

    if val && String.contains?(val, "::") do
      "crate::" <> (val |> String.split("::") |> List.last())
    else
      val
    end
  end

  defp builtin_map_lookup(_key), do: nil

  defp fetch_env_override(type_name) when is_atom(type_name),
    do: Application.get_env(:asn1scg, type_name)

  defp fetch_env_override(type_name) when is_binary(type_name) do
    case maybe_existing_atom(type_name) do
      {:ok, atom} -> Application.get_env(:asn1scg, atom)
      :error -> nil
    end
  end

  defp fetch_env_override(_), do: nil

  defp lookup_builtin_or_external(name) do
    IO.puts("Lookup builtin/external: #{name}")

    case builtin_map_lookup(name) do
      nil ->
        try do
          res = lookup(normalizeName(name))

          if name == "UnauthAttributes" do
            IO.puts("DEBUG lookup UnauthAttributes: #{inspect(res)}")
          end

          res
        rescue
          _ -> name
        end

      mapped ->
        mapped
    end
  end

  defp lookup_external(_struct_name, _field, {:Externaltypereference, _, mod, type}) do
    mod_name = mod |> bin() |> raw_pascal()
    type_name = name(type, mod)

    # Check for global overrides first (highest precedence)
    case builtin_map_lookup(type_name) do
      val when not is_nil(val) ->
        # Track cross-crate dependency (multi-crate only)
        if String.contains?(val, "::") do
          crate_name = String.split(val, "::") |> List.first()
          if crate_name != "crate", do: track_crate_dependency(crate_name)
        end

        val

      nil ->
        # Check if it should be an ASN1Node
        if is_asn1_node_type?(type_name) do
          "ASN1Node"
        else
          # Special case fix for S/MIME Capability naming mismatch if it occurs
          type_name =
            if String.ends_with?(type_name, "SMIMECAPS") and
                 not String.ends_with?(type_name, "SMIMECapabilities") do
              String.replace(type_name, "SMIMECAPS", "SMIMECapability")
            else
              type_name
            end

          external_crate = module_crate(mod_name)
          current_module = getEnv(:current_module, mod)
          current_crate = module_crate(current_module)
          module_field = fieldName(mod_name)

          type_name
        end
    end
  end

  defp lookup_external(struct_name, field, other) do
    IO.puts("Lookup external fallback for #{inspect({struct_name, field})}: #{inspect(other)}")
    other |> bin() |> normalizeName()
  end


  defp maybe_box(type, struct_name, field_name) do
    if is_boxed(struct_name, field_name) || type == struct_name or
       struct_name in ["CHAT_CHATMessage", "CHAT_CHATProtocol"] do
      "Box<#{type}>"
    else
      type
    end
  end

  defp is_boxed(struct_name, field_name) do
    boxing = :application.get_env(:asn1scg, :boxing, [])
    # Use raw_pascal to match the keys in manual_boxing
    pascal_field = field_name |> bin() |> raw_pascal()
    key = "#{struct_name}.#{pascal_field}"
    # Special case for CHAT
    if key == "CHATMessage.Body", do: true, else: Enum.member?(boxing, key)
  end


  defp emit_der_impls(rust_name, fields) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
    #{emit_sequence_decoder_body(rust_name, fields)}
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                ASN1Identifier::SEQUENCE,
                &|serializer: &mut Serializer| {
    #{emit_sequence_encoder_body(rust_name, fields)}
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """
  end

  defp emit_sequence_encoder_body(rust_name, fields) do
    fields
    |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
    |> Enum.map(&emit_struct_field_encoder(rust_name, &1))
    |> Enum.join("\n")
  end

  defp emit_struct_field_encoder(
         rust_name,
         {:ComponentType, _, field_name, {:type, tags, type, _, _, _}, optional, default, _}
       ) do
    rust_field = pad_field_name(field_name)
    field_access = "self.#{rust_field}"

    # Extract tag info
    tag_logic =
       case tags do
         [{:tag, class, number, method, _}] ->
             # class is :CONTEXT, :UNIVERSAL etc (atoms)
             # method is :IMPLICIT or :EXPLICIT
             # number is integer
             tag_class_str = case class do
                 :CONTEXT -> "TagClass::ContextSpecific"
                 :APPLICATION -> "TagClass::Application"
                 :PRIVATE -> "TagClass::Private"
                 :UNIVERSAL -> "TagClass::Universal"
                 _ -> "TagClass::ContextSpecific"
             end

             {tag_class_str, number, method}
         _ ->
             nil
       end

    # Define the serialization call for the value
    serialize_call =
        case tag_logic do
            nil ->
                "DERSerializable::serialize(val, serializer)?;"

            {cls, num, method} when method == :EXPLICIT or method == {:default, :EXPLICIT} ->
                """
                serializer.append_constructed_node(
                    ASN1Identifier::new(#{num}, #{cls}),
                    &|s: &mut Serializer| DERSerializable::serialize(val, s)
                )?;
                """

            {cls, num, method} when method == :IMPLICIT or method == {:default, :IMPLICIT} ->
                """
                {
                    let mut mh = Serializer::new();
                    val.serialize(&mut mh)?;
                    let mut bytes = mh.serialized_bytes().to_vec();
                    if bytes.len() > 0 {
                        let is_constructed = (bytes[0] & 0x20) != 0;
                        let tag_byte = 0x80 | (if is_constructed { 0x20 } else { 0 }) | (#{num} as u8);
                        bytes[0] = tag_byte;
                        let node = ASN1Node {
                            identifier: ASN1Identifier::new(#{num}, #{cls}),
                            encoded_bytes: bytes.into(),
                            content: rust_asn1::asn1::Content::Primitive(bytes::Bytes::new()),
                        };
                        node.serialize(serializer)?;
                    }
                }
                """
        end

    cond do
      optional == :OPTIONAL ->
        """
                    if let Some(val) = &#{field_access} {
                        #{serialize_call}
                    }
        """

      default != :asn1_NOVALUE ->
         # Handle DEFAULT
         """
                     // Default handling omitted for brevity, always serialize
                     #{String.replace(serialize_call, "val.", field_access <> ".")}
         """
         # Wait, if serialize_call uses 'val', we need to bind val, or replace usage.
         # For DEFAULT, the field is NOT Option (usually), so we access it directly.
         # For simplicity, if not Optional, we just serialize.

      true ->
        # Mandatory field
        """
                    {
                        let val = &#{field_access};
                        #{serialize_call}
                    }
        """
    end
  end

  defp emit_struct_field_encoder(_rust_name, _other), do: ""

  @impl true
  def integerValue(name, value, modname, saveFlag) do
    rust_name = name(name, modname)

    val_str =
      case value do
        {:Externalvaluereference, _, mod, val_name} ->
          # Assuming the external module is imported or we can reference it fully qualified
          # For simplicity, let's try to map it to the generated name
          ref_mod_name = bin(mod) |> normalizeName()
          ref_val_name = bin(val_name)

          # If it's in the same "package" (x-series), the module name might need adjustment
          # referencing crate::generated::SnakeCaseMod::UpperVal

          mod_snake = snake_case(ref_mod_name)
          rust_val_name = name(ref_val_name, ref_mod_name)
          val_upper = String.upcase(rust_val_name)

          # We might need to ensure the module is public/accessible.
          # Generate a path or simple name
          # Manual value overrides
          value_map = %{
            "PKCS9UBNAME" => "crate::upper_bounds::upperboundsubname::UPPERBOUNDSUBNAME"
          }

          val_str =
            if Map.has_key?(value_map, val_upper) do
              Map.get(value_map, val_upper)
            else
              "crate::#{mod_snake}::#{val_upper}"
            end

          val_str =
            if String.contains?(val_str, "::") do
              "crate::" <> (val_str |> String.split("::") |> List.last())
            else
              val_str
            end

        v when is_integer(v) ->
          "#{v}"

        _ ->
          # Fallback for other potential types, or error
          inspect(value)
      end

    const_body = """
    #{@generated_header}pub const #{String.upcase(rust_name)}: i64 = #{val_str};
    """

    save(saveFlag, modname, snake_case(rust_name), const_body)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:SEQUENCE, _, _, _, fields} = seq,
         modname
       ) do
    nested_name = fieldType(struct_name, field_name, seq) |> substituteType()
    sequence(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:SET, _, _, _, fields} = set_def, modname) do
    nested_name = fieldType(struct_name, field_name, set_def) |> substituteType()
    set(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:CHOICE, cases} = choice_def, modname) do
    nested_name = fieldType(struct_name, field_name, choice_def) |> substituteType()
    choice(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:ENUMERATED, cases} = enum_def, modname) do
    nested_name = fieldType(struct_name, field_name, enum_def) |> substituteType()
    enumeration(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SEQUENCE OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"Sequence Of", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SET OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(_struct_name, _field_name, _type, _modname), do: :ok

  defp emit_choice_der_impls(rust_name, cases) do
    # Generate arms with proper IMPLICIT tag swapping and EXPLICIT peeling
    arms =
      cases
      |> Enum.with_index()
      |> Enum.flat_map(fn
        {{:ComponentType, attrs, field_name, {:type, type_tags, type, _, _, _}, _optional, _, _}, idx} ->
          variant = field_name |> raw_pascal() |> escape_reserved_variant()
          type_name = field_type_for(rust_name, field_name, type, [])
          type_fish = String.replace(type_name, "<", "::<")

          # Determine expected tag from type_tags or fallback to universal
          {expected_tag_no, expected_tag_class} = case type_tags do
            [{:tag, class, number, _method, _}] ->
              cls_str = case class do
                :universal -> "TagClass::Universal"
                :UNIVERSAL -> "TagClass::Universal"
                :application -> "TagClass::Application"
                :APPLICATION -> "TagClass::Application"
                :context -> "TagClass::ContextSpecific"
                :CONTEXT -> "TagClass::ContextSpecific"
                :private -> "TagClass::Private"
                :PRIVATE -> "TagClass::Private"
                _ -> "TagClass::ContextSpecific"
              end
              {number, cls_str}

            _ ->
               # No explicit tags. Resolve universal tag.
               ut = universal_tag(type)
               if ut do
                 {ut, "TagClass::Universal"}
               else
                 # Fallback for ANY or unknown (this might fail at runtime if not handled via ANY match)
                 # But sticking to context-specific index fallback only if we can't resolve universal
                 # and we need to distinguish (though this really implies invalid ASN.1 if untagged ambiguous choice)
                 {idx, "TagClass::ContextSpecific"}
               end
          end

          # Determine tagging method for peeling logic
          tag_method = case type_tags do
            [{:tag, _class, _number, method, _}] -> method
            _ -> :IMPLICIT # Default assumption if no tags, we just read value?
          end

          tag_method = case tag_method do
            {:IMPLICIT, _} -> :IMPLICIT
            {:EXPLICIT, _} -> :EXPLICIT
            {:default, :IMPLICIT} -> :IMPLICIT
            {:default, :EXPLICIT} -> :EXPLICIT
            other -> other
          end

          # Determine innermost universal tag for tag swapping (if IMPLICIT and explicit tag was provided)
          universal_tag_no = universal_tag(type)

          # Generate the parsing call based on tagging method
          call = cond do
            is_raw_node?(type_name) ->
              "node"

            String.starts_with?(type_name, "Vec") ->
              elem_type = vector_element(type_name)
              if is_raw_node?(elem_type) do
                ~s|if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.into_iter().collect::<Vec<#{elem_type}>>() } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected constructed".to_string(), file!().to_string(), line!())); }|
              else
                "rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node)?"
              end

            String.starts_with?(type_name, "Box") ->
              inner = strip_generic(type_name, "Box<")
              inner_fish = String.replace(inner, "<", "::<")
              if is_raw_node?(inner) do
                "Box::new(node)"
              else
                "Box::new(#{inner_fish}::from_der_node(node)?)"
              end

            tag_method in [:EXPLICIT, {:default, :EXPLICIT}] ->
              # EXPLICIT: Peel outer tag to get inner node
              """
              {
                  if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                      let mut iter = collection.into_iter();
                      let inner_node = iter.next().ok_or(ASN1Error::new(
                          rust_asn1::errors::ErrorCode::InvalidASN1Object,
                          \"Expected inner node for Explicit #{variant}\".to_string(),
                          file!().to_string(),
                          line!(),
                      ))?;
                      #{type_fish}::from_der_node(inner_node)?
                  } else {
                      return Err(ASN1Error::new(
                          rust_asn1::errors::ErrorCode::UnexpectedFieldType,
                          \"Expected Constructed for Explicit #{variant}\".to_string(),
                          file!().to_string(),
                          line!(),
                      ));
                  }
              }
              """

            true ->
              # IMPLICIT or No Tag:
              should_swap = type_tags != [] and universal_tag_no != nil and expected_tag_no != universal_tag_no

              if should_swap do
                  """
                  {
                      let mut node = node;
                      node.identifier = ASN1Identifier::new(#{universal_tag_no}, TagClass::Universal);
                      #{type_fish}::from_der_node(node)?
                  }
                  """
              else
                  "#{type_fish}::from_der_node(node)?"
              end
          end

          ["            (#{expected_tag_no}, #{expected_tag_class}) => Ok(Self::#{variant}(#{call})),"]

        _ ->
          []
      end)
      |> Enum.join("\n")

    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            match (node.identifier.tag_number, node.identifier.tag_class) {
    #{arms}
                _ => Err(ASN1Error::new(
                    rust_asn1::errors::ErrorCode::UnexpectedFieldType,
                    format!(\"{}\", node.identifier),
                    file!().to_string(),
                    line!(),
                )),
            }
        }
    }

    #{emit_choice_encoder_body(rust_name, cases)}
    """
  end



  defp emit_enum_der_impls(rust_name, cases) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            let integer = ASN1Integer::from_der_node(node)?;
            // Attempt to convert BigInt to i64
            // ASN1Integer usually wraps BigInt in `value`.
            // We need to import TryInto or use a conversion method.
            // Using `TryInto` requires `use std::convert::TryInto;` in scope or prelude.
            // If `ASN1Integer` doesn't impl `TryInto<i64>`, maybe `integer.value` does.
            // Assuming `integer.value` is BigInt and `num_traits` or similar is available via `rust-asn1`.
            // If not available, we can try formatting to string and parsing (slow but robust fallback?).
            // Or assume `try_into` works on `value`.
            // Error said: `required for ASN1Integer to implement TryInto`. So `integer.try_into()` failed.
            // Let's try `integer.value.try_into()`.
            let val_res: Result<i64, _> = integer.value.try_into();
            let val = val_res.map_err(|_| ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Enum value out of range".to_string(), file!().to_string(), line!()))?;
            match val {
    #{emit_enum_decoder_cases(rust_name, cases)}
                _ => Err(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, format!("Unknown value for #{rust_name}: {}", val), file!().to_string(), line!()))
            }
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
             let val = self.clone() as i64;
             rust_asn1::asn1_types::ASN1Integer::from(val).serialize(serializer)?;
             Ok(())
        }
    }
    """
  end



  defp emit_choice_encoder_body(rust_name, cases) do
    match_arms =
      cases
      |> Enum.with_index()
      |> Enum.map(fn
        {{:ComponentType, _, field_name, {:type, type_tags, type, _, _, _}, _optional, _, _}, idx} ->
             variant = field_name |> raw_pascal() |> escape_reserved_variant()

             # Resolve tags
             tag_info = case type_tags do
                [{:tag, class, number, method, _}] ->
                   cls_str = case class do
                        :universal -> "TagClass::Universal"
                        :UNIVERSAL -> "TagClass::Universal"
                        :application -> "TagClass::Application"
                        :APPLICATION -> "TagClass::Application"
                        :context -> "TagClass::ContextSpecific"
                        :CONTEXT -> "TagClass::ContextSpecific"
                        :private -> "TagClass::Private"
                        :PRIVATE -> "TagClass::Private"
                        _ -> "TagClass::ContextSpecific"
                   end
                   {number, cls_str, method}
                _ -> nil
             end

             case tag_info do
                {num, cls, method} when method == :EXPLICIT or method == {:default, :EXPLICIT} ->
                   """
                               Self::#{variant}(val) => {
                                   serializer.append_constructed_node(
                                       ASN1Identifier::new(#{num}, #{cls}),
                                       &|s: &mut Serializer| val.serialize(s)
                                   )?;
                               },
                   """

                {num, cls, method} when method == :IMPLICIT or method == {:default, :IMPLICIT} ->
                    """
                               Self::#{variant}(val) => {
                                   let mut mh = Serializer::new();
                                   val.serialize(&mut mh)?;
                                   let mut bytes = mh.serialized_bytes().to_vec();
                                   if bytes.len() > 0 {
                                       let is_constructed = (bytes[0] & 0x20) != 0;
                                       let tag_byte = 0x80 | (if is_constructed { 0x20 } else { 0 }) | (#{num} as u8);
                                       bytes[0] = tag_byte;
                                       let node = ASN1Node {
                                           identifier: ASN1Identifier::new(#{num}, #{cls}),
                                           encoded_bytes: bytes.into(),
                                           content: rust_asn1::asn1::Content::Primitive(bytes::Bytes::new()),
                                       };
                                       node.serialize(serializer)?;
                                   }
                               },
                    """

                _ ->
                   # No tags or unknown method - serialize directly
                   "            Self::#{variant}(val) => val.serialize(serializer)?,"
             end


        _ -> ""
      end)
      |> Enum.join("\n")

    """
    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
             match self {
    #{match_arms}
             }
             Ok(())
        }
    }
    """
  end

  defp emit_enum_decoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{val} => Ok(#{rust_name}::#{variant}),"

      {name, val} ->
        variant = name |> raw_pascal() |> escape_reserved_variant()
        "            #{val} => Ok(#{rust_name}::#{variant}),"
    end)
    |> Enum.join("\n")
  end


  defp emit_sequence_decoder_body(rust_name, fields) do
    decoders =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, {:type, attrs, type, _, _, _}, optional, _, _} ->
          rust_field = pad_field_name(field_name)
          field_type = field_type_for(rust_name, field_name, type, optional)
          _tag_no = tagNo(attrs)
          _tag_class = tagClass(attrs)

          type_fish = String.replace(field_type, "<", "::<")

          # Extract tag info (hoisted)
          {expected_tag_no, expected_tag_class, tag_method} = case attrs do
            [{:tag, class, number, method, _}] ->
              cls = case class do
                :CONTEXT -> "TagClass::ContextSpecific"
                :APPLICATION -> "TagClass::Application"
                :PRIVATE -> "TagClass::Private"
                :UNIVERSAL -> "TagClass::Universal"
                :CONTEXT_SPECIFIC -> "TagClass::ContextSpecific"
                _ -> "TagClass::ContextSpecific"
              end
              {number, cls, method}
            _ ->
              # No explicit tag, fallback to type check based on content
              {nil, nil, nil}
          end

          case optional do
            :OPTIONAL ->
              inner_type = field_type_for(rust_name, field_name, type, [])
              # field_type already contains Option<T>, so inner_type is T
              # We need to use inner_type for the actual parsing call
              inner_type_fish = String.replace(inner_type, "<", "::<")

              if expected_tag_no != nil do
                # Has explicit tag: check tag before consuming
                if tag_method in [:EXPLICIT, {:default, :EXPLICIT}] do
                  # EXPLICIT: Peel the outer tag

                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    elem_type_fish = String.replace(elem_type, "<", "::<")
                    if is_raw_node?(elem_type) do
                      # Raw node elements - just collect
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  Some(seq_collection.into_iter().collect())
                                              } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())); }
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  Some(seq_collection.into_iter().map(|child| #{elem_type_fish}::from_der_node(child)).collect::<Result<_, _>>()?)
                                              } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())); }
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  else
                    # Non-Vec with EXPLICIT tag - check if raw node
                    if is_raw_node?(inner_type) do
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              Some(#{if String.contains?(field_type, "Box<"), do: "Box::new(inner_node)", else: "inner_node"})
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              Some(#{inner_type_fish}::from_der_node(inner_node)?)
                                          } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())); }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  end
                else
                  # IMPLICIT: Check tag, swap identifier, then parse
                  universal_tag_no = universal_tag(type)
                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    elem_type_fish = String.replace(elem_type, "<", "::<")
                    # Check if element type is raw node
                    elem_call = if is_raw_node?(elem_type) do
                      "child"
                    else
                      "#{elem_type_fish}::from_der_node(child)?"
                    end
                    if is_raw_node?(elem_type) do
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              Some(collection.into_iter().collect())
                                          } else { None }
                                      } else { None }
                                  } else { None };
                      """
                    else
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              Some(collection.into_iter().map(|child| #{elem_type_fish}::from_der_node(child)).collect::<Result<_, _>>()?)
                                          } else { None }
                                      } else { None }
                                  } else { None };
                      """
                    end
                  else
                    # Single value - check if raw node
                    if is_raw_node?(inner_type) do
                      val_expr = if String.starts_with?(inner_type, "Box<") or String.contains?(field_type, "Box<") do
                        "Box::new(nodes.next().unwrap())"
                      else
                        "nodes.next().unwrap()"
                      end

                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          Some(#{val_expr})
                                      } else { None }
                                  } else { None };
                      """
                    else
                      swap_logic = if universal_tag_no != nil do
                        "let mut node = node; node.identifier = ASN1Identifier::new(#{universal_tag_no}, TagClass::Universal);"
                      else
                        ""
                      end
                      """
                                  let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek() {
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          #{swap_logic}
                                          Some(#{inner_type_fish}::from_der_node(node)?)
                                      } else { None }
                                  } else { None };
                      """
                    end
                  end
                end
              else
                # No explicit tag - use existing type-based fallback logic
                if is_raw_node?(inner_type) or String.ends_with?(inner_type, "AttributeValue") do
                  val_stmt = if String.contains?(field_type, "Box<") do
                    "nodes.next().map(Box::new)"
                  else
                    "nodes.next()"
                  end
                  "            let #{rust_field}: #{field_type} = #{val_stmt};"
                else
                  if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    if is_raw_node?(elem_type) do
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); Some(collection.clone().into_iter().collect::<Vec<#{elem_type}>>()) } else { None } } else { None };"
                    else
                      elem_type_fish = String.replace(elem_type, "<", "::<")
                      call = "#{elem_type_fish}::from_der_node(child)"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { if let rust_asn1::asn1::Content::Constructed(collection) = &node.content { nodes.next(); match collection.clone().into_iter().map(|child| #{call}).collect::<Result<_, _>>() { Ok(v) => Some(v), Err(_) => None } } else { None } } else { None };"
                    end
                  else
                    if String.starts_with?(inner_type, "Box<") do
                      inner = strip_generic(inner_type, "Box<")
                      inner_fish = String.replace(inner, "<", "::<")
                      call = if is_raw_node?(inner), do: "Ok(node.clone())", else: "#{inner_fish}::from_der_node(node.clone())"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { match #{call} { Ok(val) => { nodes.next(); Some(Box::new(val)) }, Err(_) => None } } else { None };"
                    else
                      call = if is_raw_node?(inner_type), do: "Ok(node.clone())", else: "#{inner_type_fish}::from_der_node(node.clone())"
                      "            let #{rust_field}: #{field_type} = if let Some(node) = nodes.peek().map(|n| n.clone()) { match #{call} { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };"
                    end
                  end
                end
              end


            _ ->
              type_fish = String.replace(field_type, "<", "::<")
              inner_type = field_type
              inner_type_fish = type_fish

              if expected_tag_no != nil and tag_method in [:EXPLICIT, {:default, :EXPLICIT}] do
                 # Handle EXPLICIT tag for mandatory/default field (Robust version)

                 # Logic mirrors OPTIONAL branch but returns Result<T> instead of Option<T>

                 if String.starts_with?(inner_type, "Vec") do
                    elem_type = vector_element(inner_type)
                    elem_type_fish = String.replace(elem_type, "<", "::<")

                    if is_raw_node?(elem_type) do
                      # Vec<RawNode>
                      """
                                  let #{rust_field}: #{field_type} = {
                                      let node = nodes.peek().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?;
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  Ok(seq_collection.into_iter().collect())
                                              } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())) }
                                          } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())) }
                                      } else {
                                          Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, format!("Expected Explicit Tag [#{expected_tag_no}] for #{field_name}, got {}", node.identifier), file!().to_string(), line!()))
                                      }
                                  }?;
                      """
                    else
                      # Vec<T>
                      """
                                  let #{rust_field}: #{field_type} = {
                                      let node = nodes.peek().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?;
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_seq = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              if let rust_asn1::asn1::Content::Constructed(seq_collection) = inner_seq.content {
                                                  seq_collection.into_iter().map(|child| #{elem_type_fish}::from_der_node(child)).collect::<Result<_, _>>()
                                              } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Sequence inner content".to_string(), file!().to_string(), line!())) }
                                          } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!())) }
                                      } else {
                                          Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, format!("Expected Explicit Tag [#{expected_tag_no}] for #{field_name}, got {}", node.identifier), file!().to_string(), line!()))
                                      }
                                  }?;
                      """
                    end
                 else
                    # Non-Vec
                    if is_raw_node?(inner_type) do
                      # Raw inner type
                      val_expr = if String.contains?(field_type, "Box<"), do: "Box::new(inner_node)", else: "inner_node"

                      """
                                  let #{rust_field}: #{field_type} = {
                                      let node = nodes.peek().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?;
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              Ok(#{val_expr})
                                          } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())) }
                                      } else {
                                          Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, format!("Expected Explicit Tag [#{expected_tag_no}] for #{field_name}, got {}", node.identifier), file!().to_string(), line!()))
                                      }
                                  }?;
                      """
                    else
                      # Normal type (possibly Box<T>)
                      # If Box<T>, inner_type is Box<T>. We should unbox if possible?
                      # Wait, field_type_for returns Box<T>.
                      # My simplified logic: #{inner_type_fish}::from_der_node(inner_node)
                      # If T is Box<U>, T::from_der_node exists?
                      # Yes, if `U: DERParseable`. `Box<U>` implements `DERParseable`.
                      # So `Box<U>::from_der_node` works fine IF `U` is not raw.
                      # But if `U` is raw (RawNode), `Box<RawNode>` does NOT implement `from_der_node`.
                      # I need to check if inner type is Box<RawNode>.
                      # Using `is_raw_node?`.

                      call_expr = if String.starts_with?(inner_type, "Box<") do
                          inner_inner = strip_generic(inner_type, "Box<")
                          if is_raw_node?(inner_inner) do
                             "Ok(Box::new(inner_node))"
                          else
                             "#{inner_type_fish}::from_der_node(inner_node)"
                          end
                      else
                          "#{inner_type_fish}::from_der_node(inner_node)"
                      end

                      """
                                  let #{rust_field}: #{field_type} = {
                                      let node = nodes.peek().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?;
                                      if node.identifier.tag_number == #{expected_tag_no} && node.identifier.tag_class == #{expected_tag_class} {
                                          let node = nodes.next().unwrap();
                                          if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                              let mut iter = collection.into_iter();
                                              let inner_node = iter.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Empty Explicit Tag [#{expected_tag_no}]".to_string(), file!().to_string(), line!()))?;
                                              #{call_expr}
                                          } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, "Expected Constructed for Explicit field".to_string(), file!().to_string(), line!())) }
                                      } else {
                                          Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, format!("Expected Explicit Tag [#{expected_tag_no}] for #{field_name}, got {}", node.identifier), file!().to_string(), line!()))
                                      }
                                  }?;
                      """
                    end
                 end
              else
                  # Fallback to existing logic for non-tagged or implicit
                  if String.starts_with?(field_type, "Vec") do
                    elem_type = vector_element(field_type)

                    if is_raw_node?(elem_type) do
                      "            let #{rust_field} = { let node = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?; if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.into_iter().collect::<Vec<#{elem_type}>>() } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())); } };"
                    else
                      call = "#{elem_type}::from_der_node(child)"

                      "            let #{rust_field}: Vec<#{elem_type}> = { let node = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?; if let rust_asn1::asn1::Content::Constructed(collection) = node.content { collection.clone().into_iter().map(|child| #{call}).collect::<Result<_, _>>()? } else { return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())); } };"
                    end
                  else
                    if is_raw_node?(field_type) or String.ends_with?(field_type, "AttributeValue") do
                      "            let #{rust_field} = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?;"
                    else
                      if String.starts_with?(field_type, "Box<") do
                        inner = strip_generic(field_type, "Box<")

                        inner_fish = String.replace(inner, "<", "::<")
                        call =
                          if is_raw_node?(inner) do
                            "Ok(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)"
                          else
                            "#{inner_fish}::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)"
                          end

                        "            let #{rust_field} = Box::new(#{call}?);"
                      else
                        call =
                          if is_raw_node?(type_fish) do
                            "nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?"
                          else
                            "#{type_fish}::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)?"
                          end

                        "            let #{rust_field} = #{call};"
                      end
                    end
                  end
              end
          end
        _ ->
          ""
      end)
      |> Enum.join("\n")

    assignments =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, _, _, _, _} ->
          rust_field = pad_field_name(field_name)
          "                #{fieldName(field_name)}: #{rust_field},"

        _ ->
          ""
      end)
      |> Enum.join("\n")

    """
    #{decoders}
                Ok(Self {
    #{assignments}
                })
    """
  end


  # Helpers adapted from SwiftEmitter

  defp tagNo([]), do: nil
  defp tagNo(x) when is_integer(x), do: x
  defp tagNo([{:tag, _, nox, _, _}]), do: nox
  defp tagNo(_), do: nil

  defp universal_tag(type_ast) do
    case type_ast do
      :BOOLEAN -> 1
      :INTEGER -> 2
      {:INTEGER, _} -> 2
      :"BIT STRING" -> 3
      {:"BIT STRING", _} -> 3
      :"OCTET STRING" -> 4
      {:"OCTET STRING", _} -> 4
      :NULL -> 5
      :"OBJECT IDENTIFIER" -> 6
      :UTF8String -> 12
      :PrintableString -> 19
      :TeletexString -> 20
      :IA5String -> 22
      :UTCTime -> 23
      :GeneralizedTime -> 24
      :VisibleString -> 26
      {:VisibleString, _} -> 26
      :NumericString -> 18
      {:NumericString, _} -> 18
      :UniversalString -> 28
      :BMPString -> 30
      {:SEQUENCE, _, _, _, _} -> 16
      {:SET, _, _, _, _} -> 17
      {:"SEQUENCE OF", _} -> 16
      {:"SET OF", _} -> 17
      {:Externaltypereference, _, _, _} -> 16
      _ -> nil
    end
  end

  @impl true
  def finalize() do
    SingleCrateGenerator.generate_single_crate(@modules, outputDir())
    :ok
  end
  def algorithmIdentifierClass(className, modname, saveFlag) do
    rust_name = name(className, modname)

    body = """
    #{@generated_header}#{rust_use_block()}
    #{@default_derives}
    pub struct #{rust_name} {
        pub algorithm: ASN1ObjectIdentifier,
        pub parameters: Option<ASN1Node>,
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
                let algorithm = ASN1ObjectIdentifier::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Missing algorithm".to_string(), file!().to_string(), line!()))?)?;
                let parameters = nodes.next();
                Ok(Self { algorithm, parameters })
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            serializer.append_constructed_node(
                ASN1Identifier::SEQUENCE,
                &|serializer: &mut Serializer| {
                    self.algorithm.serialize(serializer)?;
                    if let Some(params) = &self.parameters {
                         params.serialize(serializer)?;
                    }
                    Ok(())
                }
            )?;
            Ok(())
        }
    }
    """

    save(saveFlag, modname, snake_case(rust_name), body)
  end
end
