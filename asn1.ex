#!/usr/bin/env elixir

defmodule ASN1 do

  def fieldName({:contentType, {:Externaltypereference,_,_mod, name}}), do: normalizeName("#{name}")
  def fieldName(name), do: normalizeName("#{name}")

  def fieldType(name,field,{:ComponentType,_,_,{:type,_,oc,_,[],:no},_opt,_,_}), do: fieldType(name, field, oc)
  def fieldType(name,field,{:"SEQUENCE", _, _, _, _}), do: bin(name) <> "_" <> bin(field) <> "_Sequence"
  def fieldType(name,field,{:"CHOICE",_}), do: bin(name) <> "_" <> bin(field) <> "_Choice"
  def fieldType(name,field,{:"ENUMERATED",_}), do: bin(name) <> "_" <> bin(field) <> "_Enum"
  def fieldType(name,field,{:"INTEGER",_}), do: bin(name) <> "_" <> bin(field) <> "_IntEnum"
  def fieldType(name,field,{:"SEQUENCE OF", type}) do bin = sequenceOf(name,field,type) ; array(bin, partArray(bin), :sequence) end
  def fieldType(name,field,{:"SET OF", type}) do bin = sequenceOf(name,field,type) ; array(bin, partArray(bin), :set) end
  def fieldType(_,_,{:contentType, {:Externaltypereference,_,_,type}}), do: "#{type}"
  def fieldType(_,_,{:"BIT STRING", _}), do: "ASN1BitString"
  def fieldType(_,_,{:pt, {_,_,_,type}, _}) when is_atom(type), do: "#{type}"
  def fieldType(_,_,{:ANY_DEFINED_BY, type}) when is_atom(type), do: "ASN1Any"
  def fieldType(_,_,{:Externaltypereference,_,_,type}), do: "#{type}"
  def fieldType(_,_,{:ObjectClassFieldType,_,_,[{_,type}],_}), do: "#{type}"
  def fieldType(_,_,type) when is_atom(type), do: "#{type}"
  def fieldType(name,_,_), do: "#{name}"

  def sequenceOf(name,field,{:type,_,{:Externaltypereference,_,_,type},_,_,_}), do: "[#{sequenceOf(name,field,type)}]"
  def sequenceOf(name,field,{:type,_,{:CHOICE, cases} = sum,_,_,_}) do
      choice(fieldType(name,field,sum), cases, [], true) ; "[" <> bin(name) <> "_" <> bin(field) <> "_Choice]" end
  def sequenceOf(name,field,{:type,_,{:SEQUENCE, _, _, _, fields} = product,_,_,_}) do
      sequence(fieldType(name,field,product), fields, [], true) ; "[" <> bin(name) <> "_" <> bin(field) <> "_Sequence]" end
  def sequenceOf(name,field,{:type,_,type,_,_,_}) do "[#{sequenceOf(name,field,type)}]" end
  def sequenceOf(_,_,{:Externaltypereference, _, _, name}) do :application.get_env(:asn1scg, bin(name), bin(name)) end
  def sequenceOf(_,_,x) when is_tuple(x), do: substituteType(bin(:erlang.element(1, x)))
  def sequenceOf(_,_,x) when is_atom(x), do: substituteType("#{lookup(x)}")
  def sequenceOf(_,_,x) when is_binary(x), do: substituteType("#{lookup(x)}")

  def substituteType("TeletexString"),     do: "ASN1TeletexString"
  def substituteType("UniversalString"),   do: "ASN1UniversalString"
  def substituteType("IA5String"),         do: "ASN1IA5String"
  def substituteType("UTF8String"),        do: "ASN1UTF8String"
  def substituteType("PrintableString"),   do: "ASN1PrintableString"
  def substituteType("NumericString"),     do: "ASN1PrintableString"
  def substituteType("BMPString"),         do: "ASN1BMPString"
  def substituteType("INTEGER"),           do: "ArraySlice<UInt8>"
  def substituteType("OCTET STRING"),      do: "ASN1OctetString"
  def substituteType("BIT STRING"),        do: "ASN1BitString"
  def substituteType("OBJECT IDENTIFIER"), do: "ASN1ObjectIdentifier"
  def substituteType("BOOLEAN"),           do: "Bool"
  def substituteType("pt"),                do: "ASN1Any"
  def substituteType("ANY"),               do: "ASN1Any"
  def substituteType("NULL"),              do: "ASN1Null"
  def substituteType("URI"),               do: "ASN1OctetString"
  def substituteType(t),                   do: t

  def emitImprint(), do: "// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023 Namdak Tonpa."
  def emitArg(name), do: "#{name}: #{name}"
  def emitCtorBodyElement(name), do: "self.#{name} = #{name}"
  def emitCtorParam(name, type, opt \\ ""), do: "#{name}: #{normalizeName(type)}#{opt}"
  def emitCtor(params,fields), do: pad(4) <> "@inlinable init(#{params}) {\n#{fields}\n    }\n"
  def emitEnumElement(type, field, value), do: pad(4) <> "static let #{field} = #{type}(rawValue: #{value})\n"
  def emitIntegerEnumElement(field, value), do: pad(4) <> "public static let #{field} = Self(rawValue: #{value})\n"
  def emitOptional(:OPTIONAL, name, body), do: "if let #{name} = self.#{name} { #{body} }"
  def emitOptional(_, _, body), do: "#{body}"
  def emitSequenceElement(name, type), do: "@usableFromInline var #{name}: #{lookup(normalizeName(type))}\n"
  def emitSequenceElementOptional(name, type, opt \\ ""), do: "@usableFromInline var #{name}: #{lookup(normalizeName(type))}#{opt}\n"

  # Vector Decoder

  def emitSequenceDecoderBodyElement(:OPTIONAL, plicit, no, name, type) when plicit == "Implicit", do:
      "let #{name}: #{type}? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific))"
  def emitSequenceDecoderBodyElement(:OPTIONAL, plicit, no, name, type) when plicit == "Explicit", do:
      "let #{name}: #{type}? = try DER.optionalExplicitlyTagged(&nodes, tagNumber: #{no}, tagClass: .contextSpecific) { node in return try #{type}(derEncoded: node) }"
  def emitSequenceDecoderBodyElement(_, plicit, no, name, type) when plicit == "Explicit", do:
      "let #{name}: #{type} = try DER.explicitlyTagged(&nodes, tagNumber: #{no}, tagClass: .contextSpecific) { node in return try #{type}(derEncoded: node) }"
  def emitSequenceDecoderBodyElement(_, plicit, no, name, type) when plicit == "Implicit", do:
      "let #{name}: #{type} = (try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific)))!"
  def emitSequenceDecoderBodyElement(optional, _, _, name, type), do:
      "let #{name}: #{type}#{opt(optional)} = try #{type}(derEncoded: &nodes)"

  def emitSequenceDecoderBodyElementArray(:OPTIONAL, plicit, no, name, type, spec) when plicit == "Explicit" and no != [] and (spec == "set" or spec == "sequence"), do:
      "let #{name}: [#{type}]? = try DER.optionalExplicitlyTagged(&nodes, tagNumber: #{no}, tagClass: .contextSpecific) { node in try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, rootNode: node) }"
  def emitSequenceDecoderBodyElementArray(_, plicit, no, name, type, spec) when plicit == "Implicit" and no != [] and (spec == "set" or spec == "sequence"), do:
      "let #{name}: [#{type}] = try DER.#{spec}(of: #{type}.self, identifier: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific), nodes: &nodes)"
  def emitSequenceDecoderBodyElementArray(_, _, no, name, type, spec) when no != [] and (spec == "set" or spec == "sequence"), do:
      "let #{name}: [#{type}] = try DER.explicitlyTagged(&nodes, tagNumber: #{no}, tagClass: .contextSpecific) { node in try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, rootNode: node) }"
  def emitSequenceDecoderBodyElementArray(optional, _, no, name, type, spec) when no == [], do:
      "let #{name}: [#{type}]#{opt(optional)} = try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, nodes: &nodes)"
  def emitSequenceDecoderBodyElementIntEnum(name, type), do:
      "let #{name} = try #{type}(rawValue: Int(derEncoded: &nodes))"

  # Vector Encoder

  def emitSequenceEncoderBodyElement(_, plicit, no, name, s) when plicit == "Explicit" and no != [] and (s == "set" or s == "sequence"), do:
      "try coder.serialize(explicitlyTaggedWithTagNumber: #{no}, tagClass: .contextSpecific) { codec in try codec.serialize#{spec(s)}(#{name}) }"
  def emitSequenceEncoderBodyElement(_, plicit, no, name, s) when plicit == "Implicit" and no != [] and (s == "set" or s == "sequence"), do:
      "try coder.serialize#{spec(s)}(#{name}, identifier: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific))"
  def emitSequenceEncoderBodyElement(_, plicit, no, name, _) when no != [] and plicit == "Implicit", do:
      "try coder.serializeOptionalImplicitlyTagged(#{name}, withIdentifier: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific))"
  def emitSequenceEncoderBodyElement(_, plicit, no, name, _) when no != [] and plicit == "Explicit", do:
      "try coder.serialize(explicitlyTaggedWithTagNumber: #{no}, tagClass: .contextSpecific) { codec in try codec.serialize(#{name}) }"
  def emitSequenceEncoderBodyElement(_, _, no, name, spec) when spec == "sequence" and no == [], do:
      "try coder.serializeSequenceOf(#{name})"
  def emitSequenceEncoderBodyElement(_, _, no, name, spec) when spec == "set" and no == [], do:
      "try coder.serializeSetOf(#{name})"
  def emitSequenceEncoderBodyElement(_, _, no, name, _) when no == [], do:
      "try coder.serialize(#{name})"
  def emitSequenceEncoderBodyElementIntEnum(no, name) when no == [], do:
      "try coder.serialize(#{name}.rawValue)"
  def emitSequenceEncoderBodyElementIntEnum(no, name), do:
      "try coder.serialize(#{name}.rawValue, explicitlyTaggedWithTagNumber: #{no}, tagClass: .contextSpecific)"

  # Scalar Sum Component

  def emitChoiceElement(name, type), do: "case #{name}(#{lookup(bin(type))})\n"
  def emitChoiceEncoderBodyElement(w, no, name, spec) when no == [], do:
      pad(w) <> "case .#{name}(let #{name}): try coder.serialize#{spec}(#{name})"
  def emitChoiceEncoderBodyElement(w, no, name, spec), do:
      pad(w) <> "case .#{name}(let #{name}):\n" <>
      pad(w+4) <> "try coder.appendConstructedNode(\n" <>
      pad(w+4) <> "identifier: ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific),\n" <>
      pad(w+4) <> "{ coder in try coder.serialize#{spec}(#{name}) })"
  def emitChoiceDecoderBodyElement(w, no, name, type) when no == [], do:
      pad(w) <> "case #{type}.defaultIdentifier:\n" <>
      pad(w+4) <> "self = .#{name}(try #{type}(derEncoded: rootNode))"
  def emitChoiceDecoderBodyElement(w, no, name, type), do:
      pad(w) <> "case ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific):\n" <>
      pad(w+4) <> "self = .#{name}(try #{type}(derEncoded: rootNode))"

  # Vector Sum Component

  def emitChoiceDecoderBodyElementForArray(w, no, name, type, spec) when no == [], do:
      pad(w) <> "case ASN1Identifier.#{spec}:\n" <>
      pad(w+4) <> "self = .#{name}(try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, rootNode: rootNode))"
  def emitChoiceDecoderBodyElementForArray(w, no,  name, type, spec) when spec == "", do:
      pad(w) <> "case ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific):\n" <>
      pad(w+4) <> "self = .#{name}(try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, nodes: &nodes))"
  def emitChoiceDecoderBodyElementForArray(w, no,  name, type, spec), do:
      pad(w) <> "case ASN1Identifier(tagWithNumber: #{no}, tagClass: .contextSpecific):\n" <>
      pad(w+4) <> "self = .#{name}(try DER.#{spec}(of: #{type}.self, identifier: .#{spec}, rootNode: rootNode))"

  def emitSequenceDefinition(name,fields,ctor,decoder,encoder), do:
"""
#{emitImprint()}
import SwiftASN1\nimport Crypto\nimport Foundation\n
@usableFromInline struct #{name}: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }\n#{fields}#{ctor}#{decoder}#{encoder}}
"""

  def emitSetDefinition(name,fields,ctor,decoder,encoder), do:
"""
#{emitImprint()}
import SwiftASN1\nimport Crypto\nimport Foundation\n
@usableFromInline struct #{name}: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .set }\n#{fields}#{ctor}#{decoder}#{encoder}}
"""

  def emitChoiceDefinition(name,cases,decoder,encoder), do:
"""
#{emitImprint()}
import SwiftASN1\nimport Crypto\nimport Foundation\n
@usableFromInline indirect enum #{name}: DERParseable, DERSerializable, Hashable, Sendable {
#{cases}#{decoder}#{encoder}
}
"""

  def emitEnumerationDefinition(name,cases), do:
"""
#{emitImprint()}
import SwiftASN1\nimport Crypto\nimport Foundation\n
public struct #{name}: DERImplicitlyTaggable, Hashable, Sendable, RawRepresentable {
    public static var defaultIdentifier: ASN1Identifier { .enumerated }
    public var rawValue: Int
    public init(rawValue: Int) { self.rawValue = rawValue }
    public init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
        self.rawValue = try .init(derEncoded: rootNode, withIdentifier: identifier)
    }
    public func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
        try self.rawValue.serialize(into: &coder, withIdentifier: identifier)
    }
#{cases}}
"""

  def emitIntegerEnumDefinition(name,cases), do:
"""
#{emitImprint()}
public struct #{name} : Hashable, Sendable, Comparable {
    @usableFromInline  var rawValue: Int
    @inlinable public static func < (lhs: #{name}, rhs: #{name}) -> Bool { lhs.rawValue < rhs.rawValue }
    @inlinable init(rawValue: Int) { self.rawValue = rawValue }
#{cases}}
"""

  def emitChoiceDecoder(cases), do:
"""
    @inlinable init(derEncoded rootNode: ASN1Node) throws {
        switch rootNode.identifier {\n#{cases}
            default: throw ASN1Error.unexpectedFieldType(rootNode.identifier)
        }
    }
"""

  def emitChoiceEncoder(cases), do:
"""
    @inlinable func serialize(into coder: inout DER.Serializer) throws {
        switch self {\n#{cases}
        }
    }
"""

  def emitSetDecoder(fields, name, args), do:
"""
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.set(root, identifier: identifier) { nodes in\n#{fields}
            return #{normalizeName(name)}(#{args})
        }
    }
"""

  def emitSequenceDecoder(fields, name, args), do:
"""
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in\n#{fields}
            return #{normalizeName(name)}(#{args})
        }
    }
"""

  def emitSequenceEncoder(fields), do:
"""
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in\n#{fields}
        }
    }
"""

  def emitIntegerEnums(cases) when is_list(cases) do
      Enum.join(:lists.map(fn
        {:NamedNumber, fieldName, fieldValue} ->
           trace(1)
           emitIntegerEnumElement(fieldName(fieldName), fieldValue)
         _ -> ""
      end, cases), "")
  end

  def emitEnums(name, cases) when is_list(cases) do
      Enum.join(:lists.map(fn
        {:NamedNumber, fieldName, fieldValue} ->
           trace(2)
           emitEnumElement(name, fieldName(fieldName), fieldValue)
         _ -> ""
      end, cases), "")
  end


  def emitCases(name, w, cases) when is_list(cases) do
      Enum.join(:lists.map(fn
        {:ComponentType,_,fieldName,{:type,_,fieldType,_elementSet,[],:no},_optional,_,_} ->
           trace(3)
           field = fieldType(name, fieldName, fieldType)
           pad(w) <> emitChoiceElement(fieldName(fieldName), substituteType(lookup(field)))
         _ -> ""
      end, cases), "")
  end


  def emitFields(name, w, fields, modname) when is_list(fields) do
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(4)
           inclusion = :application.get_env(:asn1scg, {:type,n}, [])
           emitFields(n, w, inclusion, modname)
        {:ComponentType,_,fieldName,{:type,_,fieldType,_elementSet,[],:no},optional,_,_} ->
           trace(5)
           field = fieldType(name, fieldName, fieldType)
           case fieldType do
              {:SEQUENCE, _, _, _, fields} ->
                 sequence(fieldType(name,fieldName,fieldType), fields, modname, true)
              {:CHOICE, cases} ->
                 choice(fieldType(name,fieldName,fieldType), cases, modname, true)
              {:INTEGER, cases} ->
                 integerEnum(fieldType(name,fieldName,fieldType), cases, modname, true)
              {:ENUMERATED, cases} ->
                 enumeration(fieldType(name,fieldName,fieldType), cases, modname, true)
              {:"SEQUENCE OF", {:type, [], {:SEQUENCE, _, _, _, fields} = product, _, _, _}} ->
                 sequence(fieldType(name,fieldName,product), fields, [], true)
              {:"SEQUENCE OF", {:type, [], {:CHOICE, cases}, _, _, _} = sum} ->
                 choice(fieldType(name,fieldName,sum), cases, [], true)
              {:"SET OF", {:type, [], {:SEQUENCE, _, _, _, fields} = product, _, _, _}} ->
                 sequence(fieldType(name,fieldName,product), fields, [], true)
              {:"SET OF", {:type, [], {:CHOICE, cases}, _, _, _} = sum} ->
                 choice(fieldType(name,fieldName,sum), cases, [], true)
              _ -> :skip
           end
           pad(w) <> emitSequenceElementOptional(fieldName(fieldName), substituteType(lookup(field)), opt(optional))
         _ -> ""
      end, fields), "")
  end


  def emitCtorBody(fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(6)
           inclusion = :application.get_env(:asn1scg, {:type,n}, [])
           emitCtorBody(inclusion)
        {:ComponentType,_,fieldName,{:type,_,_type,_elementSet,[],:no},_optional,_,_} ->
           trace(7)
           pad(8) <> emitCtorBodyElement(fieldName(fieldName))
        _ -> ""
      end, fields), "\n")


  def emitChoiceEncoderBody(cases), do:
      Enum.join(:lists.map(fn
        {:ComponentType,_,fieldName,{:type,tag,{:"SEQUENCE OF", {_,_,_type,_,_,_}},_,_,_},_,_,_} ->
           trace(8)
           emitChoiceEncoderBodyElement(12, tagNo(tag), fieldName(fieldName), "SequenceOf")
        {:ComponentType,_,fieldName,{:type,tag,{:"SET OF", {_,_,_type,_,_,_}},_,_,_},_,_,_} ->
           trace(9)
           emitChoiceEncoderBodyElement(12, tagNo(tag), fieldName(fieldName), "SetOf")
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},_optional,_,_} ->
           trace(10)
#           :io.format 'tensor 1: ~p~n', [{fieldName, :application.get_env({:array, lookup(fieldType("",fieldName(fieldName),type)) })}]
#           :io.format 'choice-en: ~p~n', [{fieldName,substituteType(lookup(fieldType("",fieldName,type)))}]
           case {part(lookup(fieldType("",fieldName,type)),0,1),
                 :application.get_env(:asn1scg, {:array, lookup(fieldType("",fieldName(fieldName),type))}, [])} do
                {"[", {:set, _}} -> emitChoiceEncoderBodyElement(12, tagNo(tag), fieldName(fieldName), "SetOf")
                {"[", {:sequence, _}} -> emitChoiceEncoderBodyElement(12, tagNo(tag), fieldName(fieldName), "SequenceOf")
                _ -> emitChoiceEncoderBodyElement(12, tagNo(tag), fieldName(fieldName), "")
           end
         _ -> ""
      end, cases), "\n")

  def emitChoiceDecoderBody(cases), do:
      Enum.join(:lists.map(fn
        {:ComponentType,_,fieldName,{:type,tag,{:"SEQUENCE OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(11)
           emitChoiceDecoderBodyElementForArray(12, tagNo(tag), fieldName(fieldName),
               substituteType(lookup(fieldType("", fieldName(fieldName), type))), "sequence")
        {:ComponentType,_,fieldName,{:type,tag,{:"SET OF", {_,_,type,_,_,_}},_,_,_},_,_,_} ->
           trace(12)
           emitChoiceDecoderBodyElementForArray(12, tagNo(tag), fieldName(fieldName),
               substituteType(lookup(fieldType("", fieldName(fieldName), type))), "set")
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},_optional,_,_} ->
           trace(13)
#           :io.format 'choice-de: ~p~n', [{fieldName, substituteType(lookup(fieldType("",fieldName,type)))}]
           case {part(lookup(fieldType("",fieldName,type)),0,1),
                 :application.get_env(:asn1scg, {:array, lookup(fieldType("",fieldName(fieldName),type))}, [])} do
                {"[", {:set, inner}} -> emitChoiceDecoderBodyElementForArray(12, tagNo(tag), fieldName(fieldName), inner, "set")
                {"[", {:sequence, inner}} -> emitChoiceDecoderBodyElementForArray(12, tagNo(tag), fieldName(fieldName), inner, "sequence")
                _ -> emitChoiceDecoderBodyElement(12, tagNo(tag), fieldName(fieldName),
                        substituteType(lookup(fieldType("", fieldName(fieldName), type))))
           end
         _ -> ""
      end, cases), "\n")

  def emitSequenceDecoderBody(name,fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(14)
           inclusion = :application.get_env(:asn1scg, {:type,n}, [])
           emitSequenceDecoderBody(n, inclusion)
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},optional,_,_} ->
           look = substituteType(normalizeName(lookup(fieldType(name,fieldName,type))))
           res = case type do
                {:"SEQUENCE OF", {:type, _, inner, _, _, _}} ->
                    trace(15)
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substituteType(lookup(fieldType(name,fieldName,inner))), "sequence")
                {:"SET OF", {:type, _, inner, _, _, _}} ->
                    trace(16)
                    emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substituteType(lookup(fieldType(name,fieldName,inner))), "set")
                {:"INTEGER", _} ->
                    trace(17)
                    emitSequenceDecoderBodyElementIntEnum(fieldName(fieldName), substituteType(lookup(fieldType(name,fieldName(fieldName),type))))
                {:Externaltypereference,_,_,inner} ->
                    trace(18)
  #                  :io.format 'seq-de: ~p~n', [:application.get_env(:asn1scg, {:array, bin(inner)}, [])]
                    case :application.get_env(:asn1scg, {:array, bin(inner)}, []) do
                       {:sequence, _} -> emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substituteType(part(look,1,:erlang.size(look)-2)), "sequence")
                       {:set, _} -> emitSequenceDecoderBodyElementArray(optional, plicit(tag), tagNo(tag), fieldName(fieldName), substituteType(part(look,1,:erlang.size(look)-2)), "set")
                        _ -> emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
                    end
              _ ->  trace(19)
                    emitSequenceDecoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), look)
          end
          pad(12) <> res
         _ -> ""
      end, fields), "\n")

  def emitSequenceEncoderBody(_name, fields), do:
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,name}, _, _, :no}} ->
           trace(20)
           inclusion = :application.get_env(:asn1scg, {:type,name}, [])
           emitSequenceEncoderBody(name, inclusion)
        {:ComponentType,_,fieldName,{:type,tag,type,_elementSet,[],:no},optional,_,_} ->
           res = case type do
                {:"SEQUENCE OF", {:type, _, _innerType, _, _, _}} ->
                    trace(21)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "sequence")
                {:"SET OF", {:type, _, _innerType, _, _, _}} ->
                    trace(22)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "set")
                {:"INTEGER", _} ->
                    trace(23)
                    emitSequenceEncoderBodyElementIntEnum(tagNo(tag), fieldName(fieldName))
                {:Externaltypereference,_,_,inner} ->
                    trace(24)
 #                   :io.format 'seq-en: ~p~n', [:application.get_env(:asn1scg, {:array, bin(inner)}, [])]
                    case :application.get_env(:asn1scg, {:array, bin(inner)}, []) do
                       {:sequence, _} -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "sequence")
                       {:set, _} -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "set")
                        _ -> emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
                    end
              _ ->  trace(25)
                    emitSequenceEncoderBodyElement(optional, plicit(tag), tagNo(tag), fieldName(fieldName), "")
           end
           pad(12) <> emitOptional(optional, fieldName(fieldName), res)
         _ -> ""
      end, fields), "\n")

  def emitParams(name,fields) when is_list(fields) do
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(26)
           inclusion = :application.get_env(:asn1scg, {:type,n}, [])
           emitParams(n,inclusion)
        {:ComponentType,_,fieldName,{:type,_,type,_elementSet,[],:no},optional,_,_} ->
           trace(27)
           emitCtorParam(fieldName(fieldName), substituteType(lookup(fieldType(name,fieldName,type))), opt(optional))
         _ -> ""
      end, fields), ", ")
  end

  def emitArgs(fields) when is_list(fields) do
      Enum.join(:lists.map(fn
        {:"COMPONENTS OF", {:type, _, {_,_,_,n}, _, _, :no}} ->
           trace(28)
           inclusion = :application.get_env(:asn1scg, {:type,n}, [])
           emitArgs(inclusion)
        {:ComponentType,_,fieldName,{:type,_,_type,_elementSet,[],:no},_optional,_,_} ->
           trace(29)
           emitArg(fieldName(fieldName))
         _ ->  ""
      end, fields), ", ")
  end

  def compile() do
      {:ok, f} = :file.list_dir inputDir()
      files = :lists.filter(fn x -> [_,y] = :string.tokens(x, '.') ; y == 'asn1' end, f)
      :lists.map(fn file -> compile(false, inputDir() <> :erlang.list_to_binary(file))  end, files)
      :lists.map(fn file -> compile(true,  inputDir() <> :erlang.list_to_binary(file))  end, files)
      :io.format 'inputDir: ~ts~n', [inputDir()]
      :io.format 'outputDir: ~ts~n', [outputDir()]
      :lists.foldl(fn {{:array,x},{tag,y}}, acc -> :io.format 'env array: ~ts = [~ts] ~tp ~n', [x,y,tag]
                      {x,y}, _  when is_binary(x) -> :io.format 'env alias: ~ts = ~ts ~n', [x,y] 
                      {{:type,x},y}, _ -> :io.format 'env type: ~ts = ... ~n', [x] 
                      _, _ -> :ok
      end, [], :application.get_all_env(:asn1scg))
      :ok
  end

  def _coverage() do
      :io.format 'coverage (30 branches): ~p.~n',
         [:lists.map(fn x -> :application.get_env(:asn1scg,
              {:trace, x}, []) end,:lists.seq(1,30))] end

  def compile(save, file) do
      tokens = :asn1ct_tok.file file
      {:ok, mod} = :asn1ct_parser2.parse file, tokens
      {:module, pos, modname, defid, tagdefault, exports, imports, _, declarations} = mod
      :lists.map(fn
         {:typedef,  _, pos, name, type} -> compileType(pos, name, type, modname, save)
         {:ptypedef, _, pos, name, args, type} -> compilePType(pos, name, args, type)
         {:classdef, _, pos, name, mod, type} -> compileClass(pos, name, mod, type)
         {:valuedef, _, pos, name, type, value, mod} -> compileValue(pos, name, type, value, mod)
      end, declarations)
      compileModule(pos, modname, defid, tagdefault, exports, imports)
  end

  def array(name,type,tag) when tag == :sequence or tag == :set do
      name1 = bin(normalizeName(name))
      type1 = bin(type)
      :io.format 'set array: ~ts = [~ts] ~n', [name1, type1]
      setEnv(name1, "[#{type1}]")
      setEnv("[#{name1}]", "[[#{type1}]]")
      setEnv({:array, name1}, {tag, type1})
      name1
  end

  def compileType(_, name, typeDefinition, modname, save \\ true) do
      res = case typeDefinition do
          {:type, _, {:"INTEGER", cases}, _, [], :no} ->  setEnv(name, "Int") ; integerEnum(name, cases, modname, save)
          {:type, _, {:"ENUMERATED", cases}, _, [], :no} -> enumeration(name, cases, modname, save)
          {:type, _, {:"CHOICE", cases}, _, [], :no} -> choice(name, cases, modname, save)
          {:type, _, {:"SEQUENCE", _, _, _, fields}, _, _, :no} -> sequence(name, fields, modname, save)
          {:type, _, {:"SET", _, _, _, fields}, _, _, :no} -> set(name, fields, modname, save)
          {:type, _, {:"SEQUENCE OF", {:type, _, {_, _, _, type}, _, _, _}}, _, _, _} -> array(name,substituteType(lookup(type)),:sequence)
          {:type, _, {:"SET OF", {:type, _, {_, _, _, type}, _, _, _}}, _, _, _} -> array(name,substituteType(lookup(type)),:set)
          {:type, _, {:"BIT STRING",_}, _, [], :no} -> setEnv(name, "BIT STRING")
          {:type, _, :'BIT STRING', _, [], :no} -> setEnv(name, "BIT STRING")
          {:type, _, :'INTEGER', _set, [], :no} -> setEnv(name, "INTEGER")
          {:type, _, :'NULL', _set, [], :no} -> setEnv(name, "NULL")
          {:type, _, :'ANY', _set, [], :no} -> setEnv(name, "ANY")
          {:type, _, :'PrintableString', _set, [], :no} -> setEnv(name, "PrintableString")
          {:type, _, :'NumericString', _set, [], :no} -> setEnv(name, "PrintableString")
          {:type, _, :'IA5String', _set, [], :no} -> setEnv(name, "IA5String")
          {:type, _, :'TeletexString', _set, [], :no} -> setEnv(name, "TeletexString")
          {:type, _, :'UniversalString', _set, [], :no} -> setEnv(name, "UniversalString")
          {:type, _, :'OBJECT IDENTIFIER', _, _, :no} -> setEnv(name, "OBJECT IDENTIFIER")
          {:type, _, :'OCTET STRING', [], [], :no} -> setEnv(name, "OCTET STRING")
          {:type, _, {:ObjectClassFieldType, _, _, _, _fields}, _, _, :no} -> :skip
          {:type, _, {:Externaltypereference, _, _, ext}, _set, [], _} ->  setEnv(name, ext)
          {:type, _, {:pt, _, _}, _, [], _} -> :skip
          {:Object, _, _val} -> :skip
          {:Object, _, _, _} -> :ok
          {:ObjectSet, _, _, _, _} -> :ok
          _ -> :skip
      end
      case res do
           :skip -> :io.format 'Unhandled type definition ~p: ~p~n', [name, typeDefinition]
               _ -> :skip
      end
  end

  def compileValue(_pos, _name, _type, _value, _mod), do: []
  def compileClass(_pos, _name, _mod, _type), do: []
  def compilePType(_pos, _name, _args, _type), do: []
  def compileModule(_pos, _name, _defid, _tagdefault, _exports, _imports), do: []

  def sequence(name, fields, modname, saveFlag) do
      :application.set_env(:asn1scg, {:type,name}, fields)
      save(saveFlag, modname, name, emitSequenceDefinition(normalizeName(name),
          emitFields(name, 4, fields, modname), emitCtor(emitParams(name,fields), emitCtorBody(fields)),
          emitSequenceDecoder(emitSequenceDecoderBody(name, fields), name, emitArgs(fields)),
          emitSequenceEncoder(emitSequenceEncoderBody(name, fields))))
  end

  def set(name, fields, modname, saveFlag) do
      :application.set_env(:asn1scg, {:type,name}, fields)
      save(saveFlag, modname, name, emitSetDefinition(normalizeName(name),
          emitFields(name, 4, fields, modname), emitCtor(emitParams(name,fields), emitCtorBody(fields)),
          emitSetDecoder(emitSequenceDecoderBody(name, fields), name, emitArgs(fields)),
          emitSequenceEncoder(emitSequenceEncoderBody(name, fields))))
  end

  def choice(name, cases, modname, saveFlag) do
      save(saveFlag, modname, name, emitChoiceDefinition(normalizeName(name),
          emitCases(name, 4, cases),
          emitChoiceDecoder(emitChoiceDecoderBody(cases)),
          emitChoiceEncoder(emitChoiceEncoderBody(cases))))
  end

  def enumeration(name, cases, modname, saveFlag) do
      save(saveFlag, modname, bin(name),
           emitEnumerationDefinition(normalizeName(name),
           emitEnums(name, cases)))
  end

  def integerEnum(name, cases, modname, saveFlag) do
      save(saveFlag, modname, name,
           emitIntegerEnumDefinition(normalizeName(name),
           emitIntegerEnums(cases)))
  end

  def inputDir(), do: :application.get_env(:asn1scg, "input", "priv/apple/")
  def outputDir(), do: :application.get_env(:asn1scg, "output", "Sources/ASN1SCG/")

  def save(true, _, name, res) do
      dir = outputDir()
      :filelib.ensure_dir(dir)
      norm = normalizeName(bin(name))
      fileName = dir <> norm <> ".swift"
      :ok = :file.write_file(fileName,res)
      :io.format 'compiled: ~ts.swift~n', [norm]
  end

  def save(_, _, _, _), do: []

  def lookup(name) do
      b = bin(name)
      case :application.get_env(:asn1scg, b, b) do
           a when a == b -> bin(a)
           x -> lookup(x)
      end
  end

  def plicit([]), do: ""
  def plicit([{:tag,:CONTEXT,_,{:default,:IMPLICIT},_}]), do: "Implicit"
  def plicit([{:tag,:CONTEXT,_,{:default,:EXPLICIT},_}]), do: "Explicit"
  def plicit([{:tag,:CONTEXT,_,:IMPLICIT,_}]), do: "Implicit"
  def plicit([{:tag,:CONTEXT,_,:EXPLICIT,_}]), do: "Explicit"
  def plicit(_), do: ""

  def opt(:OPTIONAL), do: "?"
  def opt(_), do: ""
  def spec("sequence"), do: "SequenceOf"
  def spec("set"), do: "SetOf"
  def spec(_), do: ""
  def trace(x), do: setEnv({:trace, x}, x)
  def normalizeName(name), do: Enum.join(String.split("#{name}", "-"), "_")
  def setEnv(x,y), do: :application.set_env(:asn1scg, bin(x), y)
  def bin(x) when is_atom(x), do: :erlang.atom_to_binary x
  def bin(x) when is_list(x), do: :erlang.list_to_binary x
  def bin(x), do: x
  def tagNo([]), do: []
  def tagNo([{:tag,:CONTEXT,nox,_,_}]) do nox end
  def pad(x), do: String.duplicate(" ", x)
  def partArray(bin), do: part(bin, 1, :erlang.size(bin) - 2)
  def part(a, x, y) do
      case :erlang.size(a) > y - x do
           true -> :binary.part(a, x, y)
              _ -> ""
      end
  end

end

case System.argv() do
  ["compile"]      -> ASN1.compile
  ["compile",i]    -> ASN1.setEnv(:input, i <> "/") ; ASN1.compile
  ["compile",i,o]  -> ASN1.setEnv(:input, i <> "/") ; ASN1.setEnv(:output, o <> "/") ; ASN1.compile
  _ -> :io.format('Copyright © 2023 Namdak Tonpa.~n')
       :io.format('ISO 8824 ITU/IETF X.680-690 ERP/1 ASN.1 DER Compiler, version 0.9.1.~n')
       :io.format('Usage: ./asn1.ex help | compile [input] [output]~n')
end
