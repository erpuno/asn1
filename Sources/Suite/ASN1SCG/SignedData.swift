// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline struct SignedData: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }
    @usableFromInline var version: Int
    @usableFromInline var digestAlgorithms: [AlgorithmIdentifier]
    @usableFromInline var encapContentInfo: EncapsulatedContentInfo
    @usableFromInline var certificates: [Certificate]?
    @usableFromInline var crls: [CertificateList]?
    @usableFromInline var signerInfos: [SignerInfo]
    @inlinable init(version: Int, digestAlgorithms: [AlgorithmIdentifier], encapContentInfo: EncapsulatedContentInfo, certificates: [Certificate]?, crls: [CertificateList]?, signerInfos: [SignerInfo]) {
        self.version = version
        self.digestAlgorithms = digestAlgorithms
        self.encapContentInfo = encapContentInfo
        self.certificates = certificates
        self.crls = crls
        self.signerInfos = signerInfos
    }
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in
            let version: Int = try Int(derEncoded: &nodes)
            let digestAlgorithms: [AlgorithmIdentifier] = try DER.set(of: AlgorithmIdentifier.self, identifier: .set, nodes: &nodes)
            let encapContentInfo: EncapsulatedContentInfo = try EncapsulatedContentInfo(derEncoded: &nodes)
            nodes.next() ; let certificates: [Certificate]? = try DER.optionalImplicitlyTagged(&nodes, tagNumber: 0, tagClass: .contextSpecific,
               { node in return try DER.set(of: Certificate.self, identifier: .set, rootNode: node) })
            let crls: [CertificateList]? = try DER.optionalImplicitlyTagged(&nodes, tagNumber: 1, tagClass: .contextSpecific)
               { node in return try DER.set(of: CertificateList.self, identifier: .set, rootNode: node) }
            let signerInfos: [SignerInfo] = try DER.set(of: SignerInfo.self, identifier: .set, nodes: &nodes)
            return SignedData(version: version, digestAlgorithms: digestAlgorithms, encapContentInfo: encapContentInfo, certificates: certificates, crls: crls, signerInfos: signerInfos)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in
            try coder.serialize(version)
            try coder.serializeSetOf(digestAlgorithms)
            try coder.serialize(encapContentInfo)
            if let certificates = self.certificates { try coder.serializeSetOf(certificates, identifier: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific)) }
            if let crls = self.crls { try coder.serializeSetOf(crls, identifier: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific)) }
            try coder.serializeSetOf(signerInfos)
        }
    }
}
