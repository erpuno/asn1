// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline struct CryptographicMessageSyntax_2009_AuthenticatedData: DERImplicitlyTaggable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }
    @usableFromInline var version: CryptographicMessageSyntax_2009_CMSVersion
    @usableFromInline var originatorInfo: CryptographicMessageSyntax_2009_OriginatorInfo?
    @usableFromInline var recipientInfos: CryptographicMessageSyntax_2009_RecipientInfos
    @usableFromInline var macAlgorithm: CryptographicMessageSyntax_2009_MessageAuthenticationCodeAlgorithm
    @usableFromInline var digestAlgorithm: CryptographicMessageSyntax_2009_DigestAlgorithmIdentifier?
    @usableFromInline var encapContentInfo: CryptographicMessageSyntax_2009_EncapsulatedContentInfo
    @usableFromInline var authAttrs: CryptographicMessageSyntax_2009_AuthAttributes?
    @usableFromInline var mac: CryptographicMessageSyntax_2009_MessageAuthenticationCode
    @usableFromInline var unauthAttrs: CryptographicMessageSyntax_2009_UnauthAttributes?
    @inlinable init(version: CryptographicMessageSyntax_2009_CMSVersion, originatorInfo: CryptographicMessageSyntax_2009_OriginatorInfo?, recipientInfos: CryptographicMessageSyntax_2009_RecipientInfos, macAlgorithm: CryptographicMessageSyntax_2009_MessageAuthenticationCodeAlgorithm, digestAlgorithm: CryptographicMessageSyntax_2009_DigestAlgorithmIdentifier?, encapContentInfo: CryptographicMessageSyntax_2009_EncapsulatedContentInfo, authAttrs: CryptographicMessageSyntax_2009_AuthAttributes?, mac: CryptographicMessageSyntax_2009_MessageAuthenticationCode, unauthAttrs: CryptographicMessageSyntax_2009_UnauthAttributes?) {
        self.version = version
        self.originatorInfo = originatorInfo
        self.recipientInfos = recipientInfos
        self.macAlgorithm = macAlgorithm
        self.digestAlgorithm = digestAlgorithm
        self.encapContentInfo = encapContentInfo
        self.authAttrs = authAttrs
        self.mac = mac
        self.unauthAttrs = unauthAttrs

    }
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in
            let version: CryptographicMessageSyntax_2009_CMSVersion = try CryptographicMessageSyntax_2009_CMSVersion(derEncoded: &nodes)
            let originatorInfo: CryptographicMessageSyntax_2009_OriginatorInfo? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific))
            let recipientInfos: CryptographicMessageSyntax_2009_RecipientInfos = try CryptographicMessageSyntax_2009_RecipientInfos(derEncoded: &nodes)
            let macAlgorithm: CryptographicMessageSyntax_2009_MessageAuthenticationCodeAlgorithm = try CryptographicMessageSyntax_2009_MessageAuthenticationCodeAlgorithm(derEncoded: &nodes)
            let digestAlgorithm: CryptographicMessageSyntax_2009_DigestAlgorithmIdentifier? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific))
            let encapContentInfo: CryptographicMessageSyntax_2009_EncapsulatedContentInfo = try CryptographicMessageSyntax_2009_EncapsulatedContentInfo(derEncoded: &nodes)
            let authAttrs: CryptographicMessageSyntax_2009_AuthAttributes? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific))
            let mac: CryptographicMessageSyntax_2009_MessageAuthenticationCode = try CryptographicMessageSyntax_2009_MessageAuthenticationCode(derEncoded: &nodes)
            let unauthAttrs: CryptographicMessageSyntax_2009_UnauthAttributes? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific))

            return CryptographicMessageSyntax_2009_AuthenticatedData(version: version, originatorInfo: originatorInfo, recipientInfos: recipientInfos, macAlgorithm: macAlgorithm, digestAlgorithm: digestAlgorithm, encapContentInfo: encapContentInfo, authAttrs: authAttrs, mac: mac, unauthAttrs: unauthAttrs)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in
            try coder.serialize(version)
            if let originatorInfo = self.originatorInfo { try coder.serializeOptionalImplicitlyTagged(originatorInfo, withIdentifier: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific)) }
            try coder.serialize(recipientInfos)
            try coder.serialize(macAlgorithm)
            if let digestAlgorithm = self.digestAlgorithm { try coder.serializeOptionalImplicitlyTagged(digestAlgorithm, withIdentifier: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific)) }
            try coder.serialize(encapContentInfo)
            if let authAttrs = self.authAttrs { try coder.serializeOptionalImplicitlyTagged(authAttrs, withIdentifier: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific)) }
            try coder.serialize(mac)
            if let unauthAttrs = self.unauthAttrs { try coder.serializeOptionalImplicitlyTagged(unauthAttrs, withIdentifier: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific)) }

        }
    }
}
