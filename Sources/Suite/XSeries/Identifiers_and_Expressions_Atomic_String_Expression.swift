// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline indirect enum Identifiers_and_Expressions_Atomic_String_Expression: DERImplicitlyTaggable, DERParseable, DERSerializable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .enumerated }
        case string_literal(ASN1OctetString)
    case binding_reference(Identifiers_and_Expressions_Binding_Reference)
    case make_string_application(Identifiers_and_Expressions_Numeric_Expression)
    case upper_alpha_application(Identifiers_and_Expressions_Numeric_Expression)
    case lower_alpha_application(Identifiers_and_Expressions_Numeric_Expression)
    case upper_roman_application(Identifiers_and_Expressions_Numeric_Expression)
    case lower_roman_application(Identifiers_and_Expressions_Numeric_Expression)
    @inlinable init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
        switch rootNode.identifier {
        case ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific):
            self = .string_literal(try ASN1OctetString(derEncoded: rootNode, withIdentifier: rootNode.identifier))
        case ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific):
            self = .binding_reference(try Identifiers_and_Expressions_Binding_Reference(derEncoded: rootNode, withIdentifier: rootNode.identifier))
        case ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific):
            guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
            self = .make_string_application(try Identifiers_and_Expressions_Numeric_Expression(derEncoded: inner))
        case ASN1Identifier(tagWithNumber: 4, tagClass: .contextSpecific):
            guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
            self = .upper_alpha_application(try Identifiers_and_Expressions_Numeric_Expression(derEncoded: inner))
        case ASN1Identifier(tagWithNumber: 5, tagClass: .contextSpecific):
            guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
            self = .lower_alpha_application(try Identifiers_and_Expressions_Numeric_Expression(derEncoded: inner))
        case ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific):
            guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
            self = .upper_roman_application(try Identifiers_and_Expressions_Numeric_Expression(derEncoded: inner))
        case ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific):
            guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
            self = .lower_roman_application(try Identifiers_and_Expressions_Numeric_Expression(derEncoded: inner))
            default: throw ASN1Error.unexpectedFieldType(rootNode.identifier)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
        switch self {
        case .string_literal(let string_literal): try string_literal.serialize(into: &coder, withIdentifier: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific))
        case .binding_reference(let binding_reference): try binding_reference.serialize(into: &coder, withIdentifier: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific))
        case .make_string_application(let make_string_application): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific)) { coder in try make_string_application.serialize(into: &coder) }
        case .upper_alpha_application(let upper_alpha_application): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 4, tagClass: .contextSpecific)) { coder in try upper_alpha_application.serialize(into: &coder) }
        case .lower_alpha_application(let lower_alpha_application): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 5, tagClass: .contextSpecific)) { coder in try lower_alpha_application.serialize(into: &coder) }
        case .upper_roman_application(let upper_roman_application): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific)) { coder in try upper_roman_application.serialize(into: &coder) }
        case .lower_roman_application(let lower_roman_application): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific)) { coder in try lower_roman_application.serialize(into: &coder) }

        }
    }

}
