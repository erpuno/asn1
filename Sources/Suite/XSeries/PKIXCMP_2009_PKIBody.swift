// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline indirect enum PKIXCMP_2009_PKIBody: DERImplicitlyTaggable, DERParseable, DERSerializable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .enumerated }
        case ir(PKIXCRMF_2009_CertReqMessages)
    case ip(PKIXCMP_2009_CertRepMessage)
    case cr(PKIXCRMF_2009_CertReqMessages)
    case cp(PKIXCMP_2009_CertRepMessage)
    case p10cr(PKCS_10_CertificationRequest)
    case popdecc(PKIXCMP_2009_POPODecKeyChallContent)
    case popdecr(PKIXCMP_2009_POPODecKeyRespContent)
    case kur(PKIXCRMF_2009_CertReqMessages)
    case kup(PKIXCMP_2009_CertRepMessage)
    case krr(PKIXCRMF_2009_CertReqMessages)
    case krp(PKIXCMP_2009_KeyRecRepContent)
    case rr(PKIXCMP_2009_RevReqContent)
    case rp(PKIXCMP_2009_RevRepContent)
    case ccr(PKIXCRMF_2009_CertReqMessages)
    case ccp(PKIXCMP_2009_CertRepMessage)
    case ckuann(PKIXCMP_2009_CAKeyUpdAnnContent)
    case cann(PKIXCMP_2009_CertAnnContent)
    case rann(PKIXCMP_2009_RevAnnContent)
    case crlann(PKIXCMP_2009_CRLAnnContent)
    case pkiconf(PKIXCMP_2009_PKIConfirmContent)
    case nested(PKIXCMP_2009_NestedMessageContent)
    case genm(PKIXCMP_2009_GenMsgContent)
    case genp(PKIXCMP_2009_GenRepContent)
    case error(PKIXCMP_2009_ErrorMsgContent)
    case certConf(PKIXCMP_2009_CertConfirmContent)
    case pollReq(PKIXCMP_2009_PollReqContent)
    case pollRep(PKIXCMP_2009_PollRepContent)
    @inlinable init(derEncoded rootNode: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
        switch rootNode.identifier {
            case ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .ir(try PKIXCRMF_2009_CertReqMessages(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .ip(try PKIXCMP_2009_CertRepMessage(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .cr(try PKIXCRMF_2009_CertReqMessages(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .cp(try PKIXCMP_2009_CertRepMessage(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 4, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .p10cr(try PKCS_10_CertificationRequest(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 5, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .popdecc(try PKIXCMP_2009_POPODecKeyChallContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .popdecr(try PKIXCMP_2009_POPODecKeyRespContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .kur(try PKIXCRMF_2009_CertReqMessages(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 8, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .kup(try PKIXCMP_2009_CertRepMessage(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 9, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .krr(try PKIXCRMF_2009_CertReqMessages(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 10, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .krp(try PKIXCMP_2009_KeyRecRepContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 11, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .rr(try PKIXCMP_2009_RevReqContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 12, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .rp(try PKIXCMP_2009_RevRepContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 13, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .ccr(try PKIXCRMF_2009_CertReqMessages(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 14, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .ccp(try PKIXCMP_2009_CertRepMessage(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 15, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .ckuann(try PKIXCMP_2009_CAKeyUpdAnnContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 16, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .cann(try PKIXCMP_2009_CertAnnContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 17, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .rann(try PKIXCMP_2009_RevAnnContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 18, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .crlann(try PKIXCMP_2009_CRLAnnContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 19, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .pkiconf(try PKIXCMP_2009_PKIConfirmContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 20, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .nested(try PKIXCMP_2009_NestedMessageContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 21, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .genm(try PKIXCMP_2009_GenMsgContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 22, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .genp(try PKIXCMP_2009_GenRepContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 23, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .error(try PKIXCMP_2009_ErrorMsgContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 24, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .certConf(try PKIXCMP_2009_CertConfirmContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 25, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .pollReq(try PKIXCMP_2009_PollReqContent(derEncoded: inner))
            case ASN1Identifier(tagWithNumber: 26, tagClass: .contextSpecific):
                guard case .constructed(let nodes) = rootNode.content, var iterator = Optional(nodes.makeIterator()), let inner = iterator.next() else { throw ASN1Error.invalidASN1Object(reason: "Invalid explicit tag content") }
                self = .pollRep(try PKIXCMP_2009_PollRepContent(derEncoded: inner))
            default: throw ASN1Error.unexpectedFieldType(rootNode.identifier)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
        switch self {
            case .ir(let ir): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific)) { coder in try ir.serialize(into: &coder) }
            case .ip(let ip): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific)) { coder in try ip.serialize(into: &coder) }
            case .cr(let cr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific)) { coder in try cr.serialize(into: &coder) }
            case .cp(let cp): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific)) { coder in try cp.serialize(into: &coder) }
            case .p10cr(let p10cr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 4, tagClass: .contextSpecific)) { coder in try p10cr.serialize(into: &coder) }
            case .popdecc(let popdecc): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 5, tagClass: .contextSpecific)) { coder in try popdecc.serialize(into: &coder) }
            case .popdecr(let popdecr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific)) { coder in try popdecr.serialize(into: &coder) }
            case .kur(let kur): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific)) { coder in try kur.serialize(into: &coder) }
            case .kup(let kup): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 8, tagClass: .contextSpecific)) { coder in try kup.serialize(into: &coder) }
            case .krr(let krr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 9, tagClass: .contextSpecific)) { coder in try krr.serialize(into: &coder) }
            case .krp(let krp): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 10, tagClass: .contextSpecific)) { coder in try krp.serialize(into: &coder) }
            case .rr(let rr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 11, tagClass: .contextSpecific)) { coder in try rr.serialize(into: &coder) }
            case .rp(let rp): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 12, tagClass: .contextSpecific)) { coder in try rp.serialize(into: &coder) }
            case .ccr(let ccr): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 13, tagClass: .contextSpecific)) { coder in try ccr.serialize(into: &coder) }
            case .ccp(let ccp): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 14, tagClass: .contextSpecific)) { coder in try ccp.serialize(into: &coder) }
            case .ckuann(let ckuann): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 15, tagClass: .contextSpecific)) { coder in try ckuann.serialize(into: &coder) }
            case .cann(let cann): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 16, tagClass: .contextSpecific)) { coder in try cann.serialize(into: &coder) }
            case .rann(let rann): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 17, tagClass: .contextSpecific)) { coder in try rann.serialize(into: &coder) }
            case .crlann(let crlann): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 18, tagClass: .contextSpecific)) { coder in try crlann.serialize(into: &coder) }
            case .pkiconf(let pkiconf): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 19, tagClass: .contextSpecific)) { coder in try pkiconf.serialize(into: &coder) }
            case .nested(let nested): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 20, tagClass: .contextSpecific)) { coder in try nested.serialize(into: &coder) }
            case .genm(let genm): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 21, tagClass: .contextSpecific)) { coder in try genm.serialize(into: &coder) }
            case .genp(let genp): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 22, tagClass: .contextSpecific)) { coder in try genp.serialize(into: &coder) }
            case .error(let error): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 23, tagClass: .contextSpecific)) { coder in try error.serialize(into: &coder) }
            case .certConf(let certConf): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 24, tagClass: .contextSpecific)) { coder in try certConf.serialize(into: &coder) }
            case .pollReq(let pollReq): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 25, tagClass: .contextSpecific)) { coder in try pollReq.serialize(into: &coder) }
            case .pollRep(let pollRep): try coder.appendConstructedNode(identifier: ASN1Identifier(tagWithNumber: 26, tagClass: .contextSpecific)) { coder in try pollRep.serialize(into: &coder) }
        }
    }

}
