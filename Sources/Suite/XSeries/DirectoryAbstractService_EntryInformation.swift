// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline struct DirectoryAbstractService_EntryInformation: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }
    @usableFromInline var name: PKIX1Explicit88_Name
    @usableFromInline var fromEntry: Bool?
    @usableFromInline var information: [DirectoryAbstractService_EntryInformation_information_Choice]?
    @usableFromInline var incompleteEntry: Bool?
    @usableFromInline var partialNameResolution: Bool?
    @inlinable init(name: PKIX1Explicit88_Name, fromEntry: Bool?, information: [DirectoryAbstractService_EntryInformation_information_Choice]?, incompleteEntry: Bool?, partialNameResolution: Bool?) {
        self.name = name
        self.fromEntry = fromEntry
        self.information = information
        self.incompleteEntry = incompleteEntry
        self.partialNameResolution = partialNameResolution
    }
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in
            let name: PKIX1Explicit88_Name = try PKIX1Explicit88_Name(derEncoded: &nodes)
            let fromEntry: Bool = try DER.decodeDefault(&nodes, defaultValue: false)
            let information: [DirectoryAbstractService_EntryInformation_information_Choice]? = try DER.set(of: DirectoryAbstractService_EntryInformation_information_Choice.self, identifier: .set, nodes: &nodes)
            let incompleteEntry: Bool = try DER.explicitlyTagged(&nodes, tagNumber: 3, tagClass: .contextSpecific) { node in return try Bool(derEncoded: node) }
            let partialNameResolution: Bool = try DER.explicitlyTagged(&nodes, tagNumber: 4, tagClass: .contextSpecific) { node in return try Bool(derEncoded: node) }
            return DirectoryAbstractService_EntryInformation(name: name, fromEntry: fromEntry, information: information, incompleteEntry: incompleteEntry, partialNameResolution: partialNameResolution)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in
            try coder.serialize(name)
            if let fromEntry = self.fromEntry { if let fromEntry = self.fromEntry { try coder.serialize(fromEntry) } }
            if let information = self.information { if let information = self.information { try coder.serializeSetOf(information) } }
            if let incompleteEntry = self.incompleteEntry { if let incompleteEntry = self.incompleteEntry { try coder.serialize(explicitlyTaggedWithTagNumber: 3, tagClass: .contextSpecific) { codec in try codec.serialize(incompleteEntry) } } }
            if let partialNameResolution = self.partialNameResolution { if let partialNameResolution = self.partialNameResolution { try coder.serialize(explicitlyTaggedWithTagNumber: 4, tagClass: .contextSpecific) { codec in try codec.serialize(partialNameResolution) } } }
        }
    }
}
