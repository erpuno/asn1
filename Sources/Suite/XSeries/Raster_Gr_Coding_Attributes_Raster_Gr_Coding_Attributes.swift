// Generated by ASN1.ERP.UNO Compiler, Copyright © 2023—2024 Namdak Tönpa.
import SwiftASN1
import Foundation

@usableFromInline struct Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .set }
    @usableFromInline var number_of_pels_per_line: ArraySlice<UInt8>?
    @usableFromInline var number_of_lines: ArraySlice<UInt8>?
    @usableFromInline var compression: Raster_Gr_Coding_Attributes_Compression?
    @usableFromInline var number_of_discarded_pels: ArraySlice<UInt8>?
    @usableFromInline var bits_per_colour_component: Raster_Gr_Coding_Attributes_Bits_Per_Colour_Component?
    @usableFromInline var interleaving_format: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_interleaving_format_IntEnum?
    @usableFromInline var number_of_pels_per_tile_line: ArraySlice<UInt8>?
    @usableFromInline var number_of_lines_per_tile: ArraySlice<UInt8>?
    @usableFromInline var tiling_offset: Raster_Gr_Presentation_Attributes_Coordinate_Pair?
    @usableFromInline var tile_types: [Raster_Gr_Coding_Attributes_Tile_Type]?
    @usableFromInline var subsampling: Raster_Gr_Coding_Attributes_Subsampling?
    @usableFromInline var jpeg_coding_mode: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_coding_mode_IntEnum
    @usableFromInline var jpeg_quantization_table: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_quantization_table_IntEnum?
    @usableFromInline var jpeg_huffman_table: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_huffman_table_IntEnum
    @usableFromInline var jbig_differential_layer: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jbig_differential_layer_IntEnum?
    @usableFromInline var number_of_lines_per_stripe: ArraySlice<UInt8>?
    @inlinable init(number_of_pels_per_line: ArraySlice<UInt8>?, number_of_lines: ArraySlice<UInt8>?, compression: Raster_Gr_Coding_Attributes_Compression?, number_of_discarded_pels: ArraySlice<UInt8>?, bits_per_colour_component: Raster_Gr_Coding_Attributes_Bits_Per_Colour_Component?, interleaving_format: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_interleaving_format_IntEnum?, number_of_pels_per_tile_line: ArraySlice<UInt8>?, number_of_lines_per_tile: ArraySlice<UInt8>?, tiling_offset: Raster_Gr_Presentation_Attributes_Coordinate_Pair?, tile_types: [Raster_Gr_Coding_Attributes_Tile_Type]?, subsampling: Raster_Gr_Coding_Attributes_Subsampling?, jpeg_coding_mode: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_coding_mode_IntEnum, jpeg_quantization_table: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_quantization_table_IntEnum?, jpeg_huffman_table: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_huffman_table_IntEnum, jbig_differential_layer: Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jbig_differential_layer_IntEnum?, number_of_lines_per_stripe: ArraySlice<UInt8>?) {
        self.number_of_pels_per_line = number_of_pels_per_line
        self.number_of_lines = number_of_lines
        self.compression = compression
        self.number_of_discarded_pels = number_of_discarded_pels
        self.bits_per_colour_component = bits_per_colour_component
        self.interleaving_format = interleaving_format
        self.number_of_pels_per_tile_line = number_of_pels_per_tile_line
        self.number_of_lines_per_tile = number_of_lines_per_tile
        self.tiling_offset = tiling_offset
        self.tile_types = tile_types
        self.subsampling = subsampling
        self.jpeg_coding_mode = jpeg_coding_mode
        self.jpeg_quantization_table = jpeg_quantization_table
        self.jpeg_huffman_table = jpeg_huffman_table
        self.jbig_differential_layer = jbig_differential_layer
        self.number_of_lines_per_stripe = number_of_lines_per_stripe
    }
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.set(root, identifier: identifier) { nodes in
            let number_of_pels_per_line: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific))
            let number_of_lines: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific))
            let compression: Raster_Gr_Coding_Attributes_Compression? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific))
            let number_of_discarded_pels: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific))
            let bits_per_colour_component: Raster_Gr_Coding_Attributes_Bits_Per_Colour_Component? = try DER.optionalExplicitlyTagged(&nodes, tagNumber: 4, tagClass: .contextSpecific) { node in return try Raster_Gr_Coding_Attributes_Bits_Per_Colour_Component(derEncoded: node) }
            let interleaving_format = try Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_interleaving_format_IntEnum(rawValue: Int(derEncoded: &nodes))
            let number_of_pels_per_tile_line: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific))
            let number_of_lines_per_tile: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific))
            let tiling_offset: Raster_Gr_Presentation_Attributes_Coordinate_Pair? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 8, tagClass: .contextSpecific))
            let tile_types: [Raster_Gr_Coding_Attributes_Tile_Type]? = try DER.optionalImplicitlyTagged(&nodes, tagNumber: 9, tagClass: .contextSpecific) { node in try DER.sequence(of: Raster_Gr_Coding_Attributes_Tile_Type.self, identifier: node.identifier, rootNode: node) }
            let subsampling: Raster_Gr_Coding_Attributes_Subsampling? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 10, tagClass: .contextSpecific))
            let jpeg_coding_mode = try Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_coding_mode_IntEnum(rawValue: Int(derEncoded: &nodes))
            let jpeg_quantization_table = try Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_quantization_table_IntEnum(rawValue: Int(derEncoded: &nodes))
            let jpeg_huffman_table = try Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jpeg_huffman_table_IntEnum(rawValue: Int(derEncoded: &nodes))
            let jbig_differential_layer = try Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes_jbig_differential_layer_IntEnum(rawValue: Int(derEncoded: &nodes))
            let number_of_lines_per_stripe: ArraySlice<UInt8>? = try DER.optionalImplicitlyTagged(&nodes, tag: ASN1Identifier(tagWithNumber: 18, tagClass: .contextSpecific))
            return Raster_Gr_Coding_Attributes_Raster_Gr_Coding_Attributes(number_of_pels_per_line: number_of_pels_per_line, number_of_lines: number_of_lines, compression: compression, number_of_discarded_pels: number_of_discarded_pels, bits_per_colour_component: bits_per_colour_component, interleaving_format: interleaving_format, number_of_pels_per_tile_line: number_of_pels_per_tile_line, number_of_lines_per_tile: number_of_lines_per_tile, tiling_offset: tiling_offset, tile_types: tile_types, subsampling: subsampling, jpeg_coding_mode: jpeg_coding_mode, jpeg_quantization_table: jpeg_quantization_table, jpeg_huffman_table: jpeg_huffman_table, jbig_differential_layer: jbig_differential_layer, number_of_lines_per_stripe: number_of_lines_per_stripe)
        }
    }
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in
            if let number_of_pels_per_line = self.number_of_pels_per_line { if let number_of_pels_per_line = self.number_of_pels_per_line { try coder.serializeOptionalImplicitlyTagged(number_of_pels_per_line, withIdentifier: ASN1Identifier(tagWithNumber: 0, tagClass: .contextSpecific)) } }
            if let number_of_lines = self.number_of_lines { if let number_of_lines = self.number_of_lines { try coder.serializeOptionalImplicitlyTagged(number_of_lines, withIdentifier: ASN1Identifier(tagWithNumber: 1, tagClass: .contextSpecific)) } }
            if let compression = self.compression { if let compression = self.compression { try coder.serializeOptionalImplicitlyTagged(compression, withIdentifier: ASN1Identifier(tagWithNumber: 2, tagClass: .contextSpecific)) } }
            if let number_of_discarded_pels = self.number_of_discarded_pels { if let number_of_discarded_pels = self.number_of_discarded_pels { try coder.serializeOptionalImplicitlyTagged(number_of_discarded_pels, withIdentifier: ASN1Identifier(tagWithNumber: 3, tagClass: .contextSpecific)) } }
            if let bits_per_colour_component = self.bits_per_colour_component { if let bits_per_colour_component = self.bits_per_colour_component { try coder.serialize(explicitlyTaggedWithTagNumber: 4, tagClass: .contextSpecific) { codec in try codec.serialize(bits_per_colour_component) } } }
            if let interleaving_format = self.interleaving_format { try coder.serialize(interleaving_format.rawValue, explicitlyTaggedWithTagNumber: 5, tagClass: .contextSpecific) }
            if let number_of_pels_per_tile_line = self.number_of_pels_per_tile_line { if let number_of_pels_per_tile_line = self.number_of_pels_per_tile_line { try coder.serializeOptionalImplicitlyTagged(number_of_pels_per_tile_line, withIdentifier: ASN1Identifier(tagWithNumber: 6, tagClass: .contextSpecific)) } }
            if let number_of_lines_per_tile = self.number_of_lines_per_tile { if let number_of_lines_per_tile = self.number_of_lines_per_tile { try coder.serializeOptionalImplicitlyTagged(number_of_lines_per_tile, withIdentifier: ASN1Identifier(tagWithNumber: 7, tagClass: .contextSpecific)) } }
            if let tiling_offset = self.tiling_offset { if let tiling_offset = self.tiling_offset { try coder.serializeOptionalImplicitlyTagged(tiling_offset, withIdentifier: ASN1Identifier(tagWithNumber: 8, tagClass: .contextSpecific)) } }
            if let tile_types = self.tile_types { if let tile_types = self.tile_types { try coder.serializeSequenceOf(tile_types, identifier: ASN1Identifier(tagWithNumber: 9, tagClass: .contextSpecific)) } }
            if let subsampling = self.subsampling { if let subsampling = self.subsampling { try coder.serializeOptionalImplicitlyTagged(subsampling, withIdentifier: ASN1Identifier(tagWithNumber: 10, tagClass: .contextSpecific)) } }
            try coder.serialize(jpeg_coding_mode.rawValue, explicitlyTaggedWithTagNumber: 11, tagClass: .contextSpecific)
            if let jpeg_quantization_table = self.jpeg_quantization_table { try coder.serialize(jpeg_quantization_table.rawValue, explicitlyTaggedWithTagNumber: 12, tagClass: .contextSpecific) }
            try coder.serialize(jpeg_huffman_table.rawValue, explicitlyTaggedWithTagNumber: 13, tagClass: .contextSpecific)
            if let jbig_differential_layer = self.jbig_differential_layer { try coder.serialize(jbig_differential_layer.rawValue, explicitlyTaggedWithTagNumber: 17, tagClass: .contextSpecific) }
            if let number_of_lines_per_stripe = self.number_of_lines_per_stripe { if let number_of_lines_per_stripe = self.number_of_lines_per_stripe { try coder.serializeOptionalImplicitlyTagged(number_of_lines_per_stripe, withIdentifier: ASN1Identifier(tagWithNumber: 18, tagClass: .contextSpecific)) } }
        }
    }
}
