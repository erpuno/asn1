// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct DirectoryAbstractServiceCommonArguments {
    pub service_controls: ServiceControls,
    pub security_parameters: Option<SecurityParameters>,
    pub requestor: Option<DistinguishedName>,
    pub operation_progress: OperationProgress,
    pub aliased_rd_ns: Option<ASN1Integer>,
    pub critical_extensions: Option<ASN1BitString>,
    pub reference_type: Option<ReferenceType>,
    pub entry_only: ASN1Boolean,
    pub name_resolve_on_maste: ASN1Boolean,
    pub operation_contexts: Option<ContextSelection>,
    pub family_grouping: FamilyGrouping,
}

impl DirectoryAbstractServiceCommonArguments {
    pub fn new(service_controls: ServiceControls, security_parameters: Option<SecurityParameters>, requestor: Option<DistinguishedName>, operation_progress: OperationProgress, aliased_rd_ns: Option<ASN1Integer>, critical_extensions: Option<ASN1BitString>, reference_type: Option<ReferenceType>, entry_only: ASN1Boolean, name_resolve_on_maste: ASN1Boolean, operation_contexts: Option<ContextSelection>, family_grouping: FamilyGrouping) -> Self {
        Self {
            service_controls,
            security_parameters,
            requestor,
            operation_progress,
            aliased_rd_ns,
            critical_extensions,
            reference_type,
            entry_only,
            name_resolve_on_maste,
            operation_contexts,
            family_grouping,
        }
    }
}

impl DERParseable for DirectoryAbstractServiceCommonArguments {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;
            let service_controls = ServiceControls::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let security_parameters = if let Some(node) = nodes.peek().map(|n| n.clone()) { match SecurityParameters::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let requestor = if let Some(node) = nodes.peek().map(|n| n.clone()) { match DistinguishedName::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let operation_progress = OperationProgress::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let aliased_rd_ns = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let critical_extensions = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1BitString::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let reference_type = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ReferenceType::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let entry_only = ASN1Boolean::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let name_resolve_on_maste = ASN1Boolean::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let operation_contexts = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ContextSelection::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_grouping = FamilyGrouping::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            Ok(Self {
                service_controls: service_controls,
                security_parameters: security_parameters,
                requestor: requestor,
                operation_progress: operation_progress,
                aliased_rd_ns: aliased_rd_ns,
                critical_extensions: critical_extensions,
                reference_type: reference_type,
                entry_only: entry_only,
                name_resolve_on_maste: name_resolve_on_maste,
                operation_contexts: operation_contexts,
                family_grouping: family_grouping,
            })

        })
    }
}

impl DERSerializable for DirectoryAbstractServiceCommonArguments {
    fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
        serializer.write_sequence(|serializer| {
            self.service_controls.serialize(serializer)?;
            if let Some(val) = &self.security_parameters { val.serialize(serializer)?; }
            if let Some(val) = &self.requestor { val.serialize(serializer)?; }
            self.operation_progress.serialize(serializer)?;
            if let Some(val) = &self.aliased_rd_ns { val.serialize(serializer)?; }
            if let Some(val) = &self.critical_extensions { val.serialize(serializer)?; }
            if let Some(val) = &self.reference_type { val.serialize(serializer)?; }
            self.entry_only.serialize(serializer)?;
            self.name_resolve_on_maste.serialize(serializer)?;
            if let Some(val) = &self.operation_contexts { val.serialize(serializer)?; }
            self.family_grouping.serialize(serializer)?;
            Ok(())
        })
    }
}
