// Generated by ASN1.ERP.UNO Compiler -- Rust emitter

use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
use super::*;

#[derive(Clone, Debug)]
pub struct InformationFrameworkSearchRule {
    pub service_type: Option<ASN1ObjectIdentifier>,
    pub user_class: Option<ASN1Integer>,
    pub input_attribute_types: Option<Vec<RequestAttribute>>,
    pub attribute_combination: AttributeCombination,
    pub output_attribute_types: Option<Vec<ResultAttribute>>,
    pub default_controls: Option<ControlOptions>,
    pub mandatory_controls: Option<ControlOptions>,
    pub search_rule_controls: Option<ControlOptions>,
    pub family_grouping: Option<FamilyGrouping>,
    pub family_return: Option<FamilyReturn>,
    pub relaxation: Option<RelaxationPolicy>,
    pub additional_control: Option<Vec<AttributeType>>,
    pub allowed_subset: AllowedSubset,
    pub imposed_subset: Option<ImposedSubset>,
    pub entry_limit: Option<EntryLimit>,
}

impl InformationFrameworkSearchRule {
    pub fn new(service_type: Option<ASN1ObjectIdentifier>, user_class: Option<ASN1Integer>, input_attribute_types: Option<Vec<RequestAttribute>>, attribute_combination: AttributeCombination, output_attribute_types: Option<Vec<ResultAttribute>>, default_controls: Option<ControlOptions>, mandatory_controls: Option<ControlOptions>, search_rule_controls: Option<ControlOptions>, family_grouping: Option<FamilyGrouping>, family_return: Option<FamilyReturn>, relaxation: Option<RelaxationPolicy>, additional_control: Option<Vec<AttributeType>>, allowed_subset: AllowedSubset, imposed_subset: Option<ImposedSubset>, entry_limit: Option<EntryLimit>) -> Self {
        Self {
            service_type,
            user_class,
            input_attribute_types,
            attribute_combination,
            output_attribute_types,
            default_controls,
            mandatory_controls,
            search_rule_controls,
            family_grouping,
            family_return,
            relaxation,
            additional_control,
            allowed_subset,
            imposed_subset,
            entry_limit,
        }
    }
}

impl DERParseable for InformationFrameworkSearchRule {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
            let all_nodes: Vec<ASN1Node> = nodes.collect();
            let mut iter = all_nodes.into_iter().peekable();
            let nodes = &mut iter;

            let service_type = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1ObjectIdentifier::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let user_class = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ASN1Integer::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let input_attribute_types = if let Some(node) = nodes.peek().map(|n| n.clone()) { match rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let attribute_combination = AttributeCombination::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let output_attribute_types = if let Some(node) = nodes.peek().map(|n| n.clone()) { match rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let default_controls = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let mandatory_controls = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let search_rule_controls = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ControlOptions::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_grouping = if let Some(node) = nodes.peek().map(|n| n.clone()) { match FamilyGrouping::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let family_return = if let Some(node) = nodes.peek().map(|n| n.clone()) { match FamilyReturn::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let relaxation = if let Some(node) = nodes.peek().map(|n| n.clone()) { match RelaxationPolicy::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let additional_control = if let Some(node) = nodes.peek().map(|n| n.clone()) { match rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let allowed_subset = AllowedSubset::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Premature end of data".to_string(), file!().to_string(), line!()))?)?;
            let imposed_subset = if let Some(node) = nodes.peek().map(|n| n.clone()) { match ImposedSubset::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            let entry_limit = if let Some(node) = nodes.peek().map(|n| n.clone()) { match EntryLimit::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };
            Ok(Self {

                service_type: service_type,
                user_class: user_class,
                input_attribute_types: input_attribute_types,
                attribute_combination: attribute_combination,
                output_attribute_types: output_attribute_types,
                default_controls: default_controls,
                mandatory_controls: mandatory_controls,
                search_rule_controls: search_rule_controls,
                family_grouping: family_grouping,
                family_return: family_return,
                relaxation: relaxation,
                additional_control: additional_control,
                allowed_subset: allowed_subset,
                imposed_subset: imposed_subset,
                entry_limit: entry_limit,
            })

        })
    }
}

impl DERSerializable for InformationFrameworkSearchRule {
    fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
        serializer.write_sequence(|serializer| {

            if let Some(val) = &self.service_type { val.serialize(serializer)?; }
            if let Some(val) = &self.user_class { val.serialize(serializer)?; }
            if let Some(val) = &self.input_attribute_types { val.serialize(serializer)?; }
            self.attribute_combination.serialize(serializer)?;
            if let Some(val) = &self.output_attribute_types { val.serialize(serializer)?; }
            if let Some(val) = &self.default_controls { val.serialize(serializer)?; }
            if let Some(val) = &self.mandatory_controls { val.serialize(serializer)?; }
            if let Some(val) = &self.search_rule_controls { val.serialize(serializer)?; }
            if let Some(val) = &self.family_grouping { val.serialize(serializer)?; }
            if let Some(val) = &self.family_return { val.serialize(serializer)?; }
            if let Some(val) = &self.relaxation { val.serialize(serializer)?; }
            if let Some(val) = &self.additional_control { val.serialize(serializer)?; }
            self.allowed_subset.serialize(serializer)?;
            if let Some(val) = &self.imposed_subset { val.serialize(serializer)?; }
            if let Some(val) = &self.entry_limit { val.serialize(serializer)?; }
            Ok(())
        })
    }
}
