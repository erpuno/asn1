defmodule ASN1.RustEmitter do
  @behaviour ASN1.Emitter

  import ASN1,
    only: [bin: 1, normalizeName: 1, getEnv: 2, setEnv: 2, save: 4, lookup: 1, outputDir: 0]

  @reserved_field_names ~w(type self super Self crate use mod pub fn struct enum impl let mut ref loop match)
  @default_derives "#[derive(Clone, Debug)]"
  @generated_header "// Generated by ASN1.ERP.UNO Compiler -- Rust emitter" <> "\n"

  @builtin_type_map %{
    :'OBJECT IDENTIFIER' => "ASN1ObjectIdentifier",
    :'BIT STRING' => "ASN1BitString",
    :'OCTET STRING' => "ASN1OctetString",
    :'BOOLEAN' => "ASN1Boolean",
    :'INTEGER' => "ASN1Integer",
    :'ENUMERATED' => "ASN1Integer",
    :'NULL' => "ASN1Null",
    :'UTF8String' => "ASN1UTF8String",
    :'Printablestring' => "ASN1PrintableString",
    :'PrintableString' => "ASN1PrintableString",
    :'IA5String' => "ASN1IA5String",
    :'NumericString' => "ASN1NumericString",
    :'GeneralizedTime' => "GeneralizedTime",
    :'UTCTime' => "UTCTime",
    :'ANY' => "ASN1Node"
  }

  # Region: behaviour callbacks ----------------------------------------------------

  @impl true
  def fileExtension, do: ".rs"

  @impl true
  def builtinType(type) when is_atom(type) do
    Map.get(@builtin_type_map, type, "ASN1Node")
  end

  defp field_type_for(struct_name, field_name, type_ast, optional) do
    base =
      struct_name
      |> fieldType(field_name, type_ast)
      |> maybe_box(struct_name, field_name)

    add_optional(base, optional)
  end

  @impl true
  def name(raw_name, modname) do
    pascal_mod = raw_pascal(modname)
    pascal_type = raw_pascal(raw_name)

    cond do
      String.starts_with?(pascal_type, pascal_mod) -> pascal_type
      true -> pascal_mod <> pascal_type
    end
  end

  @impl true
  def fieldName(name) do
    name
    |> normalizeName()
    |> snake_case()
    |> escape_reserved()
  end

  @impl true
  def fieldType(struct_name, field, {:type, _, inner, _, _, _}) do
    fieldType(struct_name, field, inner)
  end

  def fieldType(_struct_name, _field, {:"SEQUENCE OF", inner}) do
    "Vec<" <> fieldType("", "", inner) <> ">"
  end

  def fieldType(_struct_name, _field, {:"SET OF", inner}) do
    "Vec<" <> fieldType("", "", inner) <> ">"
  end

  def fieldType(struct_name, field, {:"Sequence Of", inner}) do
    fieldType(struct_name, field, {:"SEQUENCE OF", inner})
  end

  def fieldType(struct_name, field, {:"Set Of", inner}) do
    fieldType(struct_name, field, {:"SET OF", inner})
  end

  def fieldType(struct_name, field, {:Externaltypereference, _, _, ref}) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, atom) when is_atom(atom) do
    atom
    |> Atom.to_string()
    |> lookup_builtin_or_external()
  end

  def fieldType(struct_name, field, other) when is_tuple(other) do
    case other do
      {:CHOICE, _} -> name("#{field}_choice", struct_name)
      {:SEQUENCE, _, _, _, _} -> name("#{field}_sequence", struct_name)
      {:SET, _, _, _, _} -> name("#{field}_set", struct_name)
      _ -> inspect(other)
    end
  end

  def fieldType(_struct_name, _field, other) when is_binary(other) do
    other
  end

  @impl true
  def array(_name, type, _tag, _level), do: "Vec<#{type}>"

  @impl true
  def sequence(name, fields, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)
    setEnv(:current_struct, rust_name)

    contents =
      [
        @generated_header,
        rust_use_block(),
        emit_struct(rust_name, fields, modname),
        emit_constructor_block(rust_name, fields),
        emit_der_impls(rust_name)
      ]
      |> Enum.join("\n")

    save(saveFlag, modname, rust_name, contents)
    ensure_generated_mod_entry(rust_name)
  end

  @impl true
  def set(name, fields, modname, saveFlag), do: sequence(name, fields, modname, saveFlag)

  @impl true
  def choice(name, _cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
#{@generated_header}use rust_asn1::asn1::ASN1Node;

#{@default_derives}
pub enum #{rust_name} {
    // TODO: populate variants
}
"""

    save(saveFlag, modname, rust_name, body)
    ensure_generated_mod_entry(rust_name)
  end

  @impl true
  def enumeration(name, _cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
#{@generated_header}#{@default_derives}
pub enum #{rust_name} {
    // TODO: enumerate values
}
"""

    save(saveFlag, modname, rust_name, body)
    ensure_generated_mod_entry(rust_name)
  end

  @impl true
  def integerEnum(name, cases, modname, saveFlag) do
    enumeration(name, cases, modname, saveFlag)
  end

  @impl true
  def substituteType(type), do: type

  @impl true
  def tagClass(_tag), do: ""

  @impl true
  def typealias(name, target, modname, saveFlag) do
    rust_name = name(name, modname)
    target_name = lookup(normalizeName(target))

    body =
      """
#{@generated_header}pub type #{rust_name} = #{target_name};
"""

    save(saveFlag, modname, rust_name, body)
    ensure_generated_mod_entry(rust_name)
  end

  @impl true
  def value(_name, _type, _val, _modname, _saveFlag), do: []

  def sequenceOf(_name, _field, type), do: "Vec<#{type}>"

  # Region: emit helpers -----------------------------------------------------------

  defp emit_struct(rust_name, fields, modname) do
    field_lines =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_struct_field(rust_name, modname, &1))
      |> Enum.join("\n")

    """
#{@default_derives}
pub struct #{rust_name} {
#{field_lines}
}
"""
  end

  defp emit_struct_field(rust_name, modname, {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}) do
    maybe_emit_nested_type(rust_name, field_name, type, modname)
    rust_field = pad_field_name(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "    pub #{rust_field}: #{final_type},"
  end

  defp emit_struct_field(_rust_name, _modname, _other), do: ""

  defp emit_constructor_block(rust_name, fields) do
    params =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_constructor_param(rust_name, &1))
      |> Enum.reject(&(&1 == ""))
      |> Enum.join(", ")

    assignments =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(fn {:ComponentType, _, field_name, _, _, _, _} ->
        fieldName(field_name)
      end)
      |> Enum.map(&"            #{&1},")
      |> Enum.join("\n")

    """
impl #{rust_name} {
    pub fn new(#{params}) -> Self {
        Self {
#{assignments}
        }
    }
}
"""
  end

  defp emit_constructor_param(rust_name, {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}) do
    rust_field = fieldName(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "#{rust_field}: #{final_type}"
  end

  defp emit_constructor_param(_rust_name, _other), do: ""

  defp add_optional(type, :OPTIONAL), do: "Option<#{type}>"
  defp add_optional(type, _), do: type

  defp pad_field_name(name) do
    name
    |> fieldName()
    |> escape_reserved()
  end

  defp rust_use_block do
    """
use std::sync::Arc;
use rust_asn1::{
    asn1::ASN1Node,
    asn1_types::*,
    der::{self, DERParseable, DERSerializable, Serializer},
    errors::ASN1Error,
};
"""
  end

  # Region: utilities --------------------------------------------------------------

  defp snake_case(value) do
    value
    |> String.replace("-", "_")
    |> String.replace(".", "_")
    |> Macro.underscore()
  end

  defp raw_pascal(value) do
    value
    |> bin()
    |> normalizeName()
    |> String.split(["_", "-", " "], trim: true)
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
  end

  defp escape_reserved(name) do
    if name in @reserved_field_names do
      name <> "_"
    else
      name
    end
  end

  defp lookup_builtin_or_external(name) do
    case Map.get(@builtin_type_map, String.to_atom(name)) do
      nil -> lookup(normalizeName(name))
      mapped -> mapped
    end
  end

  defp lookup_external(_struct_name, _field, ref) do
    key =
      ref
      |> bin()
      |> normalizeName()

    try do
      lookup(key)
    rescue
      _ -> key
    end
  end

  defp ensure_generated_mod_entry(rust_name) do
    dir = outputDir()
    mod_dir = Path.expand(dir)
    File.mkdir_p!(mod_dir)
    mod_file = Path.join(mod_dir, "mod.rs")
    module_name = rust_name |> Macro.underscore() |> String.replace("/", "_")
    line = "pub mod #{module_name};\n"

    cond do
      File.exists?(mod_file) ->
        existing = File.read!(mod_file)
        unless String.contains?(existing, line) do
          File.write!(mod_file, existing <> line)
        end

      true ->
        File.write!(mod_file, line)
    end
  end

  defp maybe_box(type, struct_name, field_name) do
    if is_boxed(struct_name, field_name) do
      "Arc<Box<#{type}>>"
    else
      type
    end
  end

  defp is_boxed(struct_name, field_name) do
    boxing = :application.get_env(:asn1scg, :boxing, [])
    key = "#{struct_name}.#{field_name}"
    Enum.member?(boxing, key)
  end

  defp emit_der_impls(rust_name) do
    """
impl DERParseable for #{rust_name} {
    fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
        der::sequence(node, ASN1Identifier::SEQUENCE, |_iter| {
            todo!("DER decoding for #{rust_name} not yet implemented")
        })
    }
}

impl DERSerializable for #{rust_name} {
    fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
        todo!("DER serialization for #{rust_name} not yet implemented")
    }
}
"""
  end

  @impl true
  def integerValue(name, value, modname, saveFlag) do
    rust_name = name(name, modname)
    const_body = """
#{@generated_header}pub const #{String.upcase(rust_name)}: i64 = #{value};
"""

    save(saveFlag, modname, rust_name, const_body)
    ensure_generated_mod_entry(rust_name)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:SEQUENCE, _, _, _, fields} = seq, modname) do
    nested_name = fieldType(struct_name, field_name, seq)
    sequence(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:SET, _, _, _, fields} = set_def, modname) do
    nested_name = fieldType(struct_name, field_name, set_def)
    set(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:CHOICE, cases} = choice_def, modname) do
    nested_name = fieldType(struct_name, field_name, choice_def)
    choice(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:"SEQUENCE OF", {:type, _, inner, _, _, _}}, modname) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:"Sequence Of", {:type, _, inner, _, _, _}}, modname) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:"SET OF", {:type, _, inner, _, _, _}}, modname) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(_struct_name, _field_name, _type, _modname), do: :ok
end
