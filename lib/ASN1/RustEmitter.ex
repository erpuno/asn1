defmodule ASN1.RustEmitter do
  IO.puts("Defining ASN1.RustEmitter module...")
  @behaviour ASN1.Emitter

  import ASN1,
    only: [bin: 1, normalizeName: 1, getEnv: 2, setEnv: 2, save: 4, lookup: 1, outputDir: 0]

  @reserved_field_names ~w(type self super Self crate use mod pub fn struct enum impl let mut ref loop match)
  @default_derives "#[derive(Clone, Debug)]"
  @generated_header "// Generated by ASN1.ERP.UNO Compiler -- Rust emitter" <> "\n"

  @builtin_type_map %{
    :"OBJECT IDENTIFIER" => "ASN1ObjectIdentifier",
    :"BIT STRING" => "ASN1BitString",
    :"OCTET STRING" => "ASN1OctetString",
    :BOOLEAN => "ASN1Boolean",
    :INTEGER => "ASN1Integer",
    :ENUMERATED => "ASN1Integer",
    :NULL => "ASN1Null",
    :UTF8String => "ASN1UTF8String",
    :Printablestring => "ASN1PrintableString",
    :PrintableString => "ASN1PrintableString",
    :IA5String => "ASN1IA5String",
    :NumericString => "ASN1NumericString",
    :GeneralizedTime => "GeneralizedTime",
    :UTCTime => "UTCTime",
    :UTCTime => "UTCTime",
    :ANY => "ASN1Node",
    :ASN1Any => "ASN1Node",
    # Mapped to OctetString or similar usually? rust_asn1 might not have it.
    :TeletexString => "ASN1UTF8String",
    :BMPString => "ASN1UTF8String",
    :UniversalString => "ASN1UTF8String",
    :GeneralString => "ASN1UTF8String",
    :GraphicString => "ASN1UTF8String",
    :VideotexString => "ASN1UTF8String",
    :ObjectDescriptor => "ASN1UTF8String",
    :VisibleString => "ASN1UTF8String",
    # Generic handling
    :TYPE_IDENTIFIER => "ASN1Node",
    # Fallback for misparsed/generic types
    :Sequence => "ASN1Node",
    :Choice => "ASN1Node",
    "TYPE-IDENTIFIER" => "ASN1Node",
    "Sequence" => "ASN1Node",
    "Choice" => "ASN1Node"
  }

  # Region: behaviour callbacks ----------------------------------------------------

  @impl true
  def fileExtension, do: ".rs"

  @impl true
  def builtinType(type) when is_atom(type) do
    Map.get(@builtin_type_map, type, "ASN1Node")
  end

  defp field_type_for(struct_name, field_name, type_ast, optional) do
    base =
      struct_name
      |> fieldType(field_name, type_ast)
      |> substituteType()
      |> maybe_box(struct_name, field_name)

    add_optional(base, optional)
  end

  @impl true
  def name(raw_name, modname) do
    pascal_mod = raw_pascal(modname)
    pascal_type = raw_pascal(raw_name)

    cond do
      String.starts_with?(pascal_type, pascal_mod) -> pascal_type
      true -> pascal_mod <> pascal_type
    end
  end

  @impl true
  def fieldName(name) do
    name
    |> normalizeName()
    |> snake_case()
    |> escape_reserved()
  end

  @impl true
  def fieldType(struct_name, field, {:type, _, inner, _, _, _}) do
    fieldType(struct_name, field, inner)
  end

  def fieldType(_struct_name, _field, {:"SEQUENCE OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(_struct_name, _field, {:"SET OF", inner}) do
    "Vec<" <> (fieldType("", "", inner) |> substituteType()) <> ">"
  end

  def fieldType(struct_name, field, {:"Sequence Of", inner}) do
    fieldType(struct_name, field, {:"SEQUENCE OF", inner})
  end

  def fieldType(struct_name, field, {:"Set Of", inner}) do
    fieldType(struct_name, field, {:"SET OF", inner})
  end

  def fieldType(struct_name, field, {:Externaltypereference, _, _, ref}) do
    lookup_external(struct_name, field, ref)
  end

  def fieldType(_struct_name, _field, atom) when is_atom(atom) do
    atom
    |> Atom.to_string()
    |> lookup_builtin_or_external()
  end

  def fieldType(struct_name, field, other) when is_tuple(other) do
    case other do
      {:CHOICE, _} ->
        name("#{field}_choice", struct_name)

      {:SEQUENCE, _, _, _, _} ->
        name("#{field}_sequence", struct_name)

      {:SET, _, _, _, _} ->
        name("#{field}_set", struct_name)

      {:ENUMERATED, _} ->
        name("#{field}_enum", struct_name)

      {:ANY_DEFINED_BY, _} ->
        "ASN1Node"

      {:INTEGER, _} ->
        "ASN1Integer"

      {:"BIT STRING", _} ->
        "ASN1BitString"

      {:"INSTANCE OF", _, _} ->
        "ASN1Node"

      name when is_binary(name) ->
        atom = String.to_atom(name)
        res = Map.get(@builtin_type_map, atom, name)

        if name in ["Sequence", "Choice", "UTF8String"] do
          IO.puts(
            "Debug fieldType: name=#{inspect(name)} atom=#{inspect(atom)} res=#{inspect(res)}"
          )
        end

        res

      _ ->
        inspect(other)
    end
  end

  def fieldType(_struct_name, _field, other) when is_binary(other) do
    substituteType(other)
  end

  @impl true
  def array(name, type, _tag, _level) do
    rust_name = name(name, getEnv(:current_module, ""))
    setEnv(name, rust_name)

    # We strip Vec<...> if it was added by sub-calls (unlikely for array call, but checking)
    inner_type =
      if String.starts_with?(type, "Vec<"), do: String.slice(type, 4..-2//1), else: type

    body = """
    #{@generated_header}#{rust_use_block()}
    use super::*;
    use std::ops::Deref;

    #[derive(Debug, Clone)]
    pub struct #{rust_name}(pub Vec<#{inner_type}>);

    impl Deref for #{rust_name} {
        type Target = Vec<#{inner_type}>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
             // If inner type is ASN1Node, we collect manually
             #{if inner_type == "ASN1Node" do
      "if let rust_asn1::asn1::Content::Constructed(collection) = node.content { Ok(Self(collection.into_iter().collect())) } else { Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected constructed\".to_string(), file!().to_string(), line!())) }"
    else
      "let vec = rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node)?; Ok(Self(vec))"
    end}
        }
    }

    impl DERSerializable for #{rust_name} {
         fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
             Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnsupportedFieldLength, "Serialization not implemented".to_string(), file!().to_string(), line!()))
         }
    }
    """

    save(true, getEnv(:current_module, ""), snake_case(rust_name), body)
    rust_name
  end

  @impl true
  def sequence(name, fields, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)
    setEnv(:current_struct, rust_name)

    contents =
      [
        @generated_header,
        rust_use_block(),
        emit_struct(rust_name, fields, modname),
        emit_constructor_block(rust_name, fields),
        emit_der_impls(rust_name, fields)
      ]
      |> Enum.join("\n")

    save(saveFlag, modname, snake_case(rust_name), contents)
  end

  @impl true
  def set(name, fields, modname, saveFlag), do: sequence(name, fields, modname, saveFlag)

  @impl true
  def choice(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_choice_variants(cases, rust_name, modname)}
      }

      #{emit_choice_der_impls(rust_name, cases)}
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def enumeration(name, cases, modname, saveFlag) do
    rust_name = name(name, modname)
    setEnv(name, rust_name)

    body =
      """
        #{@generated_header}#{rust_use_block()}
      #{@default_derives}
      pub enum #{rust_name} {
      #{emit_enum_variants(cases)}
      }

      #{emit_enum_der_impls(rust_name, cases)}
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def integerEnum(name, cases, modname, saveFlag) do
    # Treat INTEGER variants as ENUMERATED for now in Rust binding
    enumeration(name, cases, modname, saveFlag)
  end

  @impl true
  def substituteType(type) do
    type_name =
      case type do
        {:type, _, name, _, _, _} -> name
        name when is_atom(name) -> name
        name when is_binary(name) -> name
        _ -> nil
      end

    manual_map = %{
      "PKIX1Implicit_2009_GeneralNames" => "KEPGeneralNames",
      "AuthenticationFramework_IssuerSerial" => "KEPIssuerSerial",
      "LDAPModifyRequestChangesSequenceOperationEnum" =>
        "LDAPModifyRequestChangesSequenceOperation",
      "LDAPResultResultCodeEnum" => "LDAPResultResultCode",
      "LDAPSearchRequestScopeEnum" => "LDAPSearchRequestScope",
      "LDAPSearchRequestDerefAliasesEnum" => "LDAPSearchRequestDerefAliases"
    }

    replacement =
      if type_name do
        type_name_str = to_string(type_name)
        val = Map.get(manual_map, type_name_str)

        if val do
          val
        else
          case Application.get_env(:asn1scg, String.to_atom(type_name_str)) do
            nil ->
              # check atom then string in builtin map
              case Map.get(@builtin_type_map, String.to_atom(type_name_str)) do
                nil -> Map.get(@builtin_type_map, type_name_str, type_name_str)
                val -> val
              end

            app_env_val ->
              app_env_val
          end
        end
      else
        nil
      end

    case replacement do
      nil -> type
      r -> r
    end
  end

  def tagClass(_tag), do: ""

  @impl true
  def typealias(name, target, modname, saveFlag) do
    rust_name = name(name, modname)
    target_name = substituteType(target)

    body =
      """
      #{@generated_header}#{rust_use_block()}
      use super::*;

      pub type #{rust_name} = #{target_name};
      """

    save(saveFlag, modname, snake_case(rust_name), body)
  end

  @impl true
  def value(_name, _type, _val, _modname, _saveFlag), do: []

  def sequenceOf(_name, _field, type), do: "Vec<#{substituteType(type)}>"

  # Region: emit helpers -----------------------------------------------------------

  defp emit_struct(rust_name, fields, modname) do
    field_lines =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_struct_field(rust_name, modname, &1))
      |> Enum.join("\n")

    """
    #{@default_derives}
    pub struct #{rust_name} {
    #{field_lines}
    }
    """
  end

  defp emit_struct_field(
         rust_name,
         modname,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    maybe_emit_nested_type(rust_name, field_name, type, modname)
    rust_field = pad_field_name(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "    pub #{rust_field}: #{final_type},"
  end

  defp emit_struct_field(_rust_name, _modname, _other), do: ""

  defp emit_constructor_block(rust_name, fields) do
    params =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(&emit_constructor_param(rust_name, &1))
      |> Enum.reject(&(&1 == ""))
      |> Enum.join(", ")

    assignments =
      fields
      |> Enum.filter(&match?({:ComponentType, _, _, _, _, _, _}, &1))
      |> Enum.map(fn {:ComponentType, _, field_name, _, _, _, _} ->
        fieldName(field_name)
      end)
      |> Enum.map(&"            #{&1},")
      |> Enum.join("\n")

    """
    impl #{rust_name} {
        pub fn new(#{params}) -> Self {
            Self {
    #{assignments}
            }
        }
    }
    """
  end

  defp emit_constructor_param(
         rust_name,
         {:ComponentType, _, field_name, {:type, _, type, _, _, _}, optional, _, _}
       ) do
    rust_field = fieldName(field_name)
    final_type = field_type_for(rust_name, field_name, type, optional)
    "#{rust_field}: #{final_type}"
  end

  defp emit_constructor_param(_rust_name, _other), do: ""

  defp emit_choice_variants(cases, rust_name, modname) do
    cases
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _, type, _, _, _}, _optional, _, _} ->
        maybe_emit_nested_type(rust_name, field_name, type, modname)
        variant_name = raw_pascal(field_name)
        # For choice variants, we don't wrap in Option even if optional, usually?
        # Standard ASN.1 Choice doesn't have optional components in the choice map itself,
        # but the components might be types that are effectively optional?
        # Swift emitter ignores optionality here.
        type_name = field_type_for(rust_name, field_name, type, [])
        "    #{variant_name}(#{type_name}),"

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_variants(cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = raw_pascal(name)
        "    #{variant} = #{val},"

      {name, val} ->
        variant = raw_pascal(name)
        "    #{variant} = #{val},"
    end)
    |> Enum.join("\n")
  end

  defp add_optional(type, :OPTIONAL), do: "Option<#{type}>"
  defp add_optional(type, _), do: type

  defp pad_field_name(name) do
    name
    |> fieldName()
    |> escape_reserved()
  end

  defp rust_use_block do
    """
    use std::sync::Arc;
    use rust_asn1::{
        asn1::ASN1Node,
        asn1_types::*,
        der::{self, DERParseable, DERSerializable, Serializer},
        errors::ASN1Error,
    };
    use super::*;
    """
  end

  # Region: utilities --------------------------------------------------------------

  defp snake_case(value) do
    value
    |> String.replace("-", "_")
    |> String.replace(".", "_")
    |> Macro.underscore()
  end

  defp raw_pascal(value) do
    value
    |> bin()
    |> normalizeName()
    |> String.split(["_", "-", " "], trim: true)
    |> Enum.map(fn s ->
      {first, rest} = String.split_at(s, 1)
      String.upcase(first) <> rest
    end)
    |> Enum.join("")
  end

  defp escape_reserved(name) do
    if name in @reserved_field_names do
      name <> "_"
    else
      name
    end
  end

  defp lookup_builtin_or_external(name) do
    IO.puts("Lookup builtin/external: #{name}")

    case Map.get(@builtin_type_map, String.to_atom(name)) do
      nil ->
        try do
          lookup(normalizeName(name))
        rescue
          _ -> name
        end

      mapped ->
        mapped
    end
  end

  defp lookup_external(_struct_name, _field, ref) do
    key =
      ref
      |> bin()
      |> normalizeName()

    # if String.contains?(key, "PKIX") or String.contains?(key, "LDAP") do
    IO.puts("Lookup external key: #{key}")
    # end

    # Manual overrides for missing external types
    manual_map = %{
      "PKIX1Implicit_2009_GeneralNames" => "KEPGeneralNames",
      "AuthenticationFramework_IssuerSerial" => "KEPIssuerSerial",
      "LDAPModifyRequestChangesSequenceOperationEnum" => "LDAPModifyRequestChangesSequence",
      "LDAPResultResultCodeEnum" => "LDAPResultResultCode",
      "LDAPSearchRequestScopeEnum" => "LDAPSearchRequestScope",
      "LDAPSearchRequestDerefAliasesEnum" => "LDAPSearchRequestDerefAliases"
    }

    case Map.get(manual_map, key) do
      nil ->
        try do
          lookup(key)
        rescue
          _ -> key
        end

      val ->
        val
    end
  end

  defp ensure_generated_mod_entry(rust_name) do
    dir = outputDir()
    mod_dir = Path.expand(dir)
    File.mkdir_p!(mod_dir)
    mod_file = Path.join(mod_dir, "mod.rs")
    module_name = rust_name |> Macro.underscore() |> String.replace("/", "_")
    line = "pub mod #{module_name};\npub use #{module_name}::*;\n"

    cond do
      File.exists?(mod_file) ->
        existing = File.read!(mod_file)

        unless String.contains?(existing, line) do
          File.write!(mod_file, existing <> line)
        end

      true ->
        File.write!(mod_file, line)
    end
  end

  defp maybe_box(type, struct_name, field_name) do
    if is_boxed(struct_name, field_name) || type == struct_name do
      "Arc<Box<#{type}>>"
    else
      type
    end
  end

  defp is_boxed(struct_name, field_name) do
    boxing = :application.get_env(:asn1scg, :boxing, [])
    key = "#{struct_name}.#{field_name}"
    if key == "CHATMessage.body", do: true, else: Enum.member?(boxing, key)
  end

  defp emit_der_impls(rust_name, fields) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
    #{emit_sequence_decoder_body(rust_name, fields)}
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
            // Serializer does not support write_sequence in current rust-asn1 version
            Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnsupportedFieldLength, "Serialization not implemented".to_string(), file!().to_string(), line!()))
        }
    }
    """
  end

  @impl true
  def integerValue(name, value, modname, saveFlag) do
    rust_name = name(name, modname)

    const_body = """
    #{@generated_header}pub const #{String.upcase(rust_name)}: i64 = #{value};
    """

    save(saveFlag, modname, snake_case(rust_name), const_body)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:SEQUENCE, _, _, _, fields} = seq,
         modname
       ) do
    nested_name = fieldType(struct_name, field_name, seq) |> substituteType()
    sequence(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:SET, _, _, _, fields} = set_def, modname) do
    nested_name = fieldType(struct_name, field_name, set_def) |> substituteType()
    set(nested_name, fields, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:CHOICE, cases} = choice_def, modname) do
    nested_name = fieldType(struct_name, field_name, choice_def) |> substituteType()
    choice(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(struct_name, field_name, {:ENUMERATED, cases} = enum_def, modname) do
    nested_name = fieldType(struct_name, field_name, enum_def) |> substituteType()
    enumeration(nested_name, cases, modname, true)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SEQUENCE OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"Sequence Of", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(
         struct_name,
         field_name,
         {:"SET OF", {:type, _, inner, _, _, _}},
         modname
       ) do
    maybe_emit_nested_type(struct_name, field_name, inner, modname)
  end

  defp maybe_emit_nested_type(_struct_name, _field_name, _type, _modname), do: :ok

  defp emit_choice_der_impls(rust_name, cases) do
    # TODO: Implement actual choice decoding based on tags
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(_node: ASN1Node) -> Result<Self, ASN1Error> {
            // TODO: Switch on tags to decode specific variant
            todo!("DER decoding for choice #{rust_name}")
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            match self {
    #{emit_choice_encoder_cases(rust_name, cases)}
            }
        }
    }
    """
  end

  defp emit_choice_encoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      {:ComponentType, _, field_name, _, _, _, _} ->
        variant = raw_pascal(field_name)
        "            #{rust_name}::#{variant}(val) => val.serialize(serializer),"

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_der_impls(rust_name, cases) do
    """
    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            let integer = ASN1Integer::from_der_node(node)?;
            // Assuming ASN1Integer fits in i64/u64 or we can cast
            let val: i64 = integer.try_into().map_err(|_| ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, "Enum value out of range".to_string(), file!().to_string(), line!()))?;
            match val {
    #{emit_enum_decoder_cases(rust_name, cases)}
                _ => Err(ASN1Error::new(rust_asn1::errors::ErrorCode::InvalidASN1Object, format!("Unknown value for #{rust_name}: {}", val), file!().to_string(), line!()))
            }
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, serializer: &mut Serializer) -> Result<(), ASN1Error> {
            let val = match self {
    #{emit_enum_encoder_cases(rust_name, cases)}
            };
            val.serialize(serializer)
        }
    }
    """
  end

  defp emit_enum_decoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = raw_pascal(name)
        "            #{val} => Ok(#{rust_name}::#{variant}),"

      {name, val} ->
        variant = raw_pascal(name)
        "            #{val} => Ok(#{rust_name}::#{variant}),"
    end)
    |> Enum.join("\n")
  end

  defp emit_enum_encoder_cases(rust_name, cases) do
    cases
    |> Enum.map(fn
      :EXTENSIONMARK ->
        ""

      {:NamedNumber, name, val} ->
        variant = raw_pascal(name)
        "            #{rust_name}::#{variant} => #{val},"

      {name, val} ->
        variant = raw_pascal(name)
        "            #{rust_name}::#{variant} => #{val},"
    end)
    |> Enum.join("\n")
  end

  defp emit_sequence_decoder_body(rust_name, fields) do
    decoders =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, {:type, attrs, type, _, _, _}, optional, _, _} ->
          rust_field = pad_field_name(field_name)
          field_type = field_type_for(rust_name, field_name, type, optional)
          _tag_no = tagNo(attrs)
          _tag_class = tagClass(attrs)
          # TODO: Handle tagging and optionality properly
          # For now, assuming simple mandatory fields or simple optionals
          case optional do
            :OPTIONAL ->
              inner_type = field_type_for(rust_name, field_name, type, [])
              type_fish = String.replace(inner_type, "<", "::<")

              if inner_type == "ASN1Node" do
                "            let #{rust_field} = nodes.next();"
              else
                if String.starts_with?(inner_type, "Vec") do
                  if String.contains?(inner_type, "ASN1Node") do
                    # Vec<ASN1Node> special handling
                    "            let #{rust_field} = if let Some(node) = nodes.peek() {
                          nodes.next();
                          if let rust_asn1::asn1::Content::Constructed(collection) = &node.content {
                              Some(collection.clone().into_iter().collect())
                          } else {
                              None
                          }
                       } else { None };"
                  else
                    "            let #{rust_field} = if let Some(node) = nodes.peek() { match rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };"
                  end
                else
                  "            let #{rust_field} = if let Some(node) = nodes.peek() { match #{type_fish}::from_der_node(node.clone()) { Ok(val) => { nodes.next(); Some(val) }, Err(_) => None } } else { None };"
                end
              end

            _ ->
              type_fish = String.replace(field_type, "<", "::<")

              if field_type == "ASN1Node" do
                "            let #{rust_field} = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?;"
              else
                if String.starts_with?(field_type, "Vec") do
                  if String.contains?(field_type, "ASN1Node") do
                    # Vec<ASN1Node> special handling
                    "            let #{rust_field} = {
                               let node = nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?;
                               if let rust_asn1::asn1::Content::Constructed(collection) = node.content {
                                   collection.into_iter().collect()
                               } else {
                                   return Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnexpectedFieldType, \"Expected primitive\".to_string(), file!().to_string(), line!()));
                               }
                           };"
                  else
                    "            let #{rust_field} = rust_asn1::der::sequence_of(rust_asn1::asn1_types::ASN1Identifier::SEQUENCE, nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)?;"
                  end
                else
                  "            let #{rust_field} = #{type_fish}::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, \"Premature end of data\".to_string(), file!().to_string(), line!()))?)?;"
                end
              end
          end

        _ ->
          ""
      end)
      |> Enum.join("\n")

    assignments =
      fields
      |> Enum.map(fn
        {:ComponentType, _, field_name, _, _, _, _} ->
          rust_field = pad_field_name(field_name)
          "                #{fieldName(field_name)}: #{rust_field},"

        _ ->
          ""
      end)
      |> Enum.join("\n")

    """
    #{decoders}
                Ok(Self {
    #{assignments}
                })
    """
  end

  defp emit_sequence_encoder_body(rust_name, fields) do
    fields
    |> Enum.map(fn
      {:ComponentType, _, field_name, {:type, _attrs, _type, _, _, _}, optional, _, _} ->
        rust_field = pad_field_name(field_name)

        case optional do
          :OPTIONAL ->
            "            if let Some(val) = &self.#{rust_field} { val.serialize(serializer)?; }"

          _ ->
            "            self.#{rust_field}.serialize(serializer)?;"
        end

      _ ->
        ""
    end)
    |> Enum.join("\n")
  end

  # Helpers adapted from SwiftEmitter

  defp tagNo([]), do: nil
  defp tagNo(x) when is_integer(x), do: x
  defp tagNo([{:tag, _, nox, _, _}]), do: nox
  defp tagNo(_), do: nil

  @impl true
  def tagClass([]), do: nil
  def tagClass(x) when is_integer(x), do: x
  def tagClass([{:tag, :CONTEXT, _, _, _}]), do: "TagClass::ContextSpecific"
  def tagClass([{:tag, :APPLICATION, _, _, _}]), do: "TagClass::Application"
  def tagClass([{:tag, :PRIVATE, _, _, _}]), do: "TagClass::Private"
  def tagClass([{:tag, :UNIVERSAL, _, _, _}]), do: "TagClass::Universal"
  def tagClass([{:tag, class, _, _, _}]), do: class

  defp tagNo_or_default(attrs) do
    case tagNo(attrs) do
      nil -> []
      val -> val
    end
  end

  def algorithmIdentifierClass(className, modname, saveFlag) do
    rust_name = name(className, modname)

    body = """
    #{@generated_header}#{rust_use_block()}
    #{@default_derives}
    pub struct #{rust_name} {
        pub algorithm: ASN1ObjectIdentifier,
        pub parameters: Option<ASN1Node>,
    }

    impl DERParseable for #{rust_name} {
        fn from_der_node(node: ASN1Node) -> Result<Self, ASN1Error> {
            der::sequence(node, ASN1Identifier::SEQUENCE, |nodes| {
                let all_nodes: Vec<ASN1Node> = nodes.collect();
                let mut iter = all_nodes.into_iter().peekable();
                let nodes = &mut iter;
                let algorithm = ASN1ObjectIdentifier::from_der_node(nodes.next().ok_or(ASN1Error::new(rust_asn1::errors::ErrorCode::TruncatedASN1Field, "Missing algorithm".to_string(), file!().to_string(), line!()))?)?;
                let parameters = nodes.next();
                Ok(Self { algorithm, parameters })
            })
        }
    }

    impl DERSerializable for #{rust_name} {
        fn serialize(&self, _serializer: &mut Serializer) -> Result<(), ASN1Error> {
            Err(ASN1Error::new(rust_asn1::errors::ErrorCode::UnsupportedFieldLength, "Serialization not implemented".to_string(), file!().to_string(), line!()))
        }
    }
    """

    save(saveFlag, modname, snake_case(rust_name), body)
  end
end
